<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no"><title>面试八股文——操作系统 | 宁康同学</title><meta name="keywords" content="C++,操作系统,多线程,内存管理"><meta name="author" content="宁康"><meta name="copyright" content="宁康"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#f7f9fe"><meta name="mobile-web-app-capable" content="yes"><meta name="apple-touch-fullscreen" content="yes"><meta name="apple-mobile-web-app-title" content="面试八股文——操作系统"><meta name="application-name" content="面试八股文——操作系统"><meta name="apple-mobile-web-app-capable" content="yes"><meta name="apple-mobile-web-app-status-bar-style" content="#f7f9fe"><meta property="og:type" content="article"><meta property="og:title" content="面试八股文——操作系统"><meta property="og:url" content="http://example.com/2023/08/06/2023-08-6-%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/index.html"><meta property="og:site_name" content="宁康同学"><meta property="og:description" content="1、什么是进程？什么是线程？进程是资源分配的基本单位，他是程序执行是的一个实例，在程序运行是创建 线程是程序执行的最小单位，是进程的一个执行流，一个进程里包含多个线程 2.进程、线程、协程的区别？进程是资源分配的基本单位，他是程序执行是的一个实例，在程序运行是创建 线程是微进程，程序执行的最小单位，"><meta property="og:locale" content="zh-CN"><meta property="og:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta property="article:author" content="宁康"><meta property="article:tag"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg"><meta name="description" content="1、什么是进程？什么是线程？进程是资源分配的基本单位，他是程序执行是的一个实例，在程序运行是创建 线程是程序执行的最小单位，是进程的一个执行流，一个进程里包含多个线程 2.进程、线程、协程的区别？进程是资源分配的基本单位，他是程序执行是的一个实例，在程序运行是创建 线程是微进程，程序执行的最小单位，"><link rel="shortcut icon" href="/favicon.ico"><link rel="canonical" href="http://example.com/2023/08/06/2023-08-6-%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><link rel="preconnect" href="//cdn.cbd.int"/><meta name="google-site-verification" content="xxx"/><meta name="baidu-site-verification" content="code-xxx"/><meta name="msvalidate.01" content="xxx"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  linkPageTop: undefined,
  peoplecanvas: {"enable":true,"img":"https://upload-bbs.miyoushe.com/upload/2023/09/03/125766904/ee23df8517f3c3e3efc4145658269c06_5714860933110284659.png"},
  postHeadAiDescription: {"enable":true,"gptName":"AnZhiYu","mode":"local","switchBtn":false,"btnLink":"https://afdian.net/item/886a79d4db6711eda42a52540025c377","randomNum":3,"basicWordCount":1000,"key":"xxxx","Referer":"https://xx.xx/"},
  diytitle: {"enable":true,"leaveTitle":"w(ﾟДﾟ)w 不要走！再看看嘛！","backTitle":"♪(^∇^*)欢迎肥来！"},
  LA51: undefined,
  greetingBox: {"enable":true,"default":"晚上好👋","list":[{"greeting":"晚安😴","startTime":0,"endTime":5},{"greeting":"早上好鸭👋, 祝你一天好心情！","startTime":6,"endTime":9},{"greeting":"上午好👋, 状态很好，鼓励一下～","startTime":10,"endTime":10},{"greeting":"11点多啦, 在坚持一下就吃饭啦～","startTime":11,"endTime":11},{"greeting":"午安👋, 宝贝","startTime":12,"endTime":14},{"greeting":"🌈充实的一天辛苦啦！","startTime":14,"endTime":18},{"greeting":"19点喽, 奖励一顿丰盛的大餐吧🍔。","startTime":19,"endTime":19},{"greeting":"晚上好👋, 在属于自己的时间好好放松😌~","startTime":20,"endTime":24}]},
  twikooEnvId: '',
  commentBarrageConfig:undefined,
  root: '/',
  preloader: {"source":3},
  friends_vue_info: {"apiurl":"https://friends.anheyu.com/"},
  navMusic: true,
  mainTone: undefined,
  authorStatus: undefined,
  algolia: undefined,
  localSearch: undefined,
  translate: {"defaultEncoding":2,"translateDelay":0,"msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简","rightMenuMsgToTraditionalChinese":"转为繁体","rightMenuMsgToSimplifiedChinese":"转为简体"},
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":330},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    simplehomepage: true,
    post: false
  },
  runtime: '天',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: {"copy":true,"copyrightEbable":false,"limitCount":50,"languages":{"author":"作者: 宁康","link":"链接: ","source":"来源: 宁康同学","info":"著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。","copySuccess":"复制成功，复制和转载请标注本文地址"}},
  lightbox: 'fancybox',
  Snackbar: {"chs_to_cht":"你已切换为繁体","cht_to_chs":"你已切换为简体","day_to_night":"你已切换为深色模式","night_to_day":"你已切换为浅色模式","bgLight":"#425AEF","bgDark":"#1f1f1f","position":"top-center"},
  source: {
    justifiedGallery: {
      js: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.min.js',
      css: 'https://cdn.cbd.int/flickr-justified-gallery@2.1.2/dist/fjGallery.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: true,
  isAnchor: false,
  shortcutKey: undefined,
  autoDarkmode: true
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  configTitle: '宁康同学',
  title: '面试八股文——操作系统',
  postAI: '',
  pageFillDescription: '1、什么是进程？什么是线程？, 2.进程、线程、协程的区别？, 3.何时使用多进程？何时使用多线程？(考虑优缺点), 4.创建进程的方式？, 5.进程有几种状态？, 三大基本状态：, 两种常见状态：, 状态转换：, 6.进程间通信方式有哪些？, 7.进程间通信的选择, 8、什么是僵尸进程、孤儿进程、守护进程？, 9.僵尸进程有什么危害？, 10.线程间通信方法有哪些？, 11.说说线程进程同步方式有哪些？, 12.什么是内核线程和用户线程？, 12.   进程调度算法即策略有哪些？, 14.有抢占式和非抢占式的区别, 15.并发和并行, 16.进程间的通信中的管道通信实现原理是什么：, 17.说说什么死锁产生的条件如何解决？, 18.单核机械上写多线程程序是否考虑加锁为什么？, 19.互斥锁机制互斥锁和读写锁的区别？, 20.说说什么是信号量有什么作用？, 21.进程、线程的中断切换的过程是怎样的？, 22.多线程和单线程有什么区别多线程编程要注意什么多线程加锁需要注意什么？, 23.为什么要创建线程池？线程池的设计思路线程池中线程的数量由什么确定？, 24.说说多路IO复用技术有哪些区别是什么？, 25.说说多路IO复用技术有哪些区别是什么？, 26.有名管道(named pipe)的通信步骤：, 27.信号的常见知识, 1)信号的作用：用于通知接收进程有某种事件发生除了用于进程间通信还可以发送信号给自己, 2)常见信号：, 3)发送信号：, 4)进程可以对信号的操作：, 5)创建定时器：, 28.共享内存, 29.   说说软链接和硬链接的区别, 30.说说静态库和动态库怎么制作及如何使用区别是什么, 静态库的制作：, 动态库的制作, 区别什么时候加载加载速度如何内存占用大小执行效率, 31.简述GDB常见的调试命令什么是条件断点多进程下如何调试, 32.简述Linux系统态与用户态什么时候会进入系统态？, 33.    什么是页表为什么要有？, 34.   简述操作系统中malloc的实现原理, 35.    简述操作系统中的缺页中断。, 36.   简述mmap的原理和使用场景, 37.为什么使用虚拟内存, 38.用户空间和内核空间的通信方式, 38.中断的响应执行流程？听说过顶半部和底半部吗？, 39.   busybox是什么？, 40.   什么是根文件系统, 41.   自旋锁是什么？信号量是什么？二者有什么区别？, 42.   为什么堆的空间不是连续的？, 43.Linux内核的组成部分（进程、内存管理、文件系统、网络接口）, 44.Linux系统的组成部分（内核、shell、文件系统、应用程序）, 45.线程的同步和互斥的区别和联系, 46.常见命令, 1.解压、压缩命令, 2.查看内存, 3.查看cpu, 4.ps grep|xxx, 5.修改文件权限, 6.查看内核, 7.查看栈大小, 47.进程终止, 48.特殊进程, 48.   多线程中使用较多的函数, 50.pthread_cond_signal()和 pthread_cond_broadcast(), 51.驱动里面为什么需要并发和互斥, 52.   软中断和硬中断的区别, 52.   fork和vfork的区别, 53.什么是虚拟内存, 54.并发编程的三个概念, 55.   同步和异步什么是进程什么是线程进程是资源分配的基本单位他是程序执行是的一个实例在程序运行是创建线程是程序执行的最小单位是进程的一个执行流一个进程里包含多个线程进程线程协程的区别进程是资源分配的基本单位他是程序执行是的一个实例在程序运行是创建线程是微进程程序执行的最小单位是进程的一个执行流一个进程里包含多个线程协程是微线程在子程序内部执行可在子程序内部中断转而执行别的子程序在适当的时候再返回来接着执行进程和线程区别开销问题通信线程进程之间影响进程是资源最小分配单位线程是最小的执行单位也是处理器调度的基本单位进程拥有自己的独立地址空间每启动一个进程系统就会分配地址空间建立数据表来维护代码段数据段堆栈段进程的全局变量是不共用的这种开销是非常大而线程是共享进程的数据使用相同的地址空间因此切换一个线程的开销远小于进程的切换线程之间的通信更加方便同一进程下的线程共享全局变量静态数据而进程间的通信需要以通信的方式进行但是线程的缺点是同步和互斥是编写多线程的难点多进程的优点是一个进程死掉不会对另个进程有影响而多线程只要一个线程死掉整个进程就会死掉每个线程拥有自己的栈段和寄存器组线程和协程的区别协程执行效率极高协程直接操作栈基本没有内核切换的开销所以上下文切换非常快协程不需要多线程的锁机制因为多个线程从属一个线程不存在同时写冲突何时使用多进程何时使用多线程考虑优缺点对资源保护和管理要求高不限制开销和效率使用多进程要求效率高切换频繁使用多线程创建进程的方式系统初始化像后台进程守护进程一个进程开启另个进程用户的交互式请求子进程拷贝了父进程的数据段堆栈以及继承了父进程打开的文件描述符父进程与子进程并不共享这些存储空间这是子进程对父进程相应部分存储空间的完全复制执行之后每个进程均可修改各自的栈数据以及堆段中的变量而并不影响另一个进程如果是的话就会有影响在系统中系统调用用于创建一个新的进程新创建的进程是原进程的一个副本我们通常将原进程称为父进程新创建的进程称为子进程函数在父进程中返回新创建的子进程的进程在子进程中返回因此的情况是在子进程中发生的这个特性常常被用来在父进程和子进程中执行不同的代码例如在系统如中我们通常使用和系统调用来创建新的进程以下是一个简单的示例这个程序会创建一个新的进程并执行命令列出当前目录的内容在子进程中执行父进程等待子进程结束在这段代码中我们首先调用创建一个新的进程新创建的子进程是父进程的一个复制品它们的区别在于的返回值在父进程中返回的是新创建的子进程的而在子进程中返回然后我们检查的返回值以确定我们当前在哪个进程中如果我们在子进程中我们就调用来执行如果我们在父进程中我们就调用等待子进程结束注意上面的代码中并没有处理错误在实际的程序中你需要检查和的返回值并适当地处理可能出现的错误进程有几种状态三大基本状态就绪态在这种状态下进程已经准备好运行正在等待操作系统调度器分配时间片一旦可用就绪状态的进程就可以转为运行状态执行态在这种状态下进程正在使用进行计算在任何时刻在单核的系统中只有一个进程可以处于运行状态阻塞态在这种状态下进程正在等待某个条件例如操作的完成如磁盘读写或网络通信才能继续运行当这个条件满足时进程会转为就绪状态两种常见状态创建状态终止状态状态转换新建就绪当进程被创建时它首先进入新建状态一旦操作系统完成了所有的加载和初始化工作进程就会转换到就绪状态就绪运行当调度器选择了一个进程进行执行该进程就会从就绪状态变为运行状态运行就绪当时间片耗尽或有更高优先级的进程需要运行时当前运行状态的进程会被转换为就绪状态运行等待如果一个进程需要等待一个事件例如等待操作完成它会从运行状态切换到等待状态等待就绪一旦等待的事件发生例如完成进程就会从等待状态切换到就绪状态运行终止如果进程已完成执行或被显式停止它将从运行状态切换到终止状态注意在系统中进程的生命周期是从执行到终止进程间通信方式有哪些管道系统包括消息队列信号量信号共享内存套接字进程间通信管道这是最早的方法之一它允许一个进程向另一个进程发送数据管道特别适用于父子进程间的通信信号这是一种类似于软件中断的简单通信方式可以发送给其他进程或者同一进程的不同线程消息队列这是一种更复杂的方法允许进程向消息队列中发送和接收消息平台就是这种方法共享内存这是一种非常高效的方法允许多个进程读写一个共享的内存区域套接字这是一种极其强大的通信工具可以用于在运行在同一台机器或者不同机器上的进程之间进行通信信号量虽然信号量主要用于同步但它们也可以用于进程间通信特别是在关于共享资源的问题上共享内存共享内存就是映射一段能被其他进程访问的内存这段共享内存有一个进程创建但多个进程都可以访问共享内存是最快的它往往配合其他通信机制使用如信号量来实现同步和通信原理开辟一个物理内存空间各个进程物理地址映射到自己的虚拟地址空间通过虚拟地址就可以直接访问进而实现数据共享共享内存是最快的通信方式因为少了数据的拷贝开辟共享内存映射到进程虚拟地址操作数据解除映射套接字它可用于不同机器之间的进程通信其中信号量信号消息队列可以用来同步进程间通信的选择管道通信主要是应用在进程间护法短小频率很高的消息共享内存主要是在接进程间共享数据庞大读写频繁的数据因为是把物理地址映射到进程其他考虑什么是僵尸进程孤儿进程守护进程僵尸进程一个进程使用出一个子进程如果子进程退出但是父进程没有使用或者函数回收子进程的资源那么该进程就是僵尸进程孤儿进程是指父进程异常退出而子进程还没退出那么子进程就会被号进程收养守护进程是指后台进程有意把父进程先结束然后被号进程收养例如服务器打印服务器数据库服务器等都是以守护进程的形式运行的它们在后台运行独立于任何用户终端并提供特定的服务守护进程通常在系统启动时启动并在系统关闭时关闭僵尸进程有什么危害僵尸进程的进程号并不会被释放但是系统的进程号是有限的如果出现大量僵尸进程就会导致系统无进程号可用就无法产生新进程如何杀死僵尸进程可以通过杀死其父进程来结束僵尸进程线程间通信方法有哪些临界区互斥量信号量事件条件变量读写锁临界区每个线程访问临界资源的那段代码叫临界区每次只允许一个线程进入临界区进入后其他线程无法进入互斥量采用互斥对象机制只有拥有互斥对象的线程才可以访问信号量计数器允许多个线程同时访问统一资源条件变量通过条件变量通知操作的方式保持多线程同步读写锁读写锁和互斥量类似但互斥量要么是锁住状态要么就是不加锁状态读写锁一次只允许一个线程写但允许一次多个线程读这样效率就比互斥锁要高说说线程进程同步方式有哪些线程间的同步方式包括互斥锁信号量条件变量读写锁什么是内核线程和用户线程用户线程是由用户进行管理用户线程的创建调度同步和销毁全又库函数在用户空间完成不需要内核的帮助这种线程开销是比较小的内核线程由操作系统创建和销毁如何实现守护进程创建子进程终止父进程调用创建一个新会话将当前目录更改为根目录重设文件权限掩码文件权限掩码是指屏蔽掉文件权限的对应为关闭不再需要的文件描述符进程调度算法即策略有哪些先来先服务短作业优先调度高优先级优先时间片论多级反馈队列有抢占式和非抢占式的区别非抢占式优先权算法在这种方式下系统一旦把处理机分配给就绪队列中优先权最高的进程后该进程便一直执行下去直至完成抢占式优先权调度算法在这种方式下系统同样是把处理机分配给优先权最高的进程使之执行但在其执行期间只要又出现了另一个其优先权更高的进程进程调度程序就立即停止当前进程原优先权最高的进程的执行重新将处理机分配给新到的优先权最高的进程并发和并行并发是对于单个来说在一个是个只能一个进程运行但是线程的切换时间则是减少到纳秒数量级多个任务不停的来回切换并行是对于多个来说多个进程同时运行区别并行的同时是同一时刻可以多个任务在运行处于并发的同时是经过不同线程快速切换进程间的通信中的管道通信实现原理是什么操作系统在内核中开辟一块缓冲区称为管道用于通信编程步骤父进程调用开辟管道得到两个文件描述符指向管道的两端父进程调用创建子进程那么子进程也有两个文件描述符指向同一管道父进程关闭管道读端子进程关闭管道写端父进程可以往管道里写子进程可以从管道里读管道是用环形队列实现的数据从写端流入从读端流出这样就实现了进程间通信读数据发数据创建管道创建子进程执行子进程子进程向父进程写数据关闭管道的读端执行父进程父进程从管道读取子进程写的数据关闭管道的写端说说什么死锁产生的条件如何解决死锁是指多个进程在执行过程中因争夺资源而造成互相等待此时系统产生了死锁产生条件互斥条件进程对所分配的资源不允许其他进程访问若其他进程需要访问只能等待知道该进程使用完毕后释放资源请求保持条件进程获得一定资源后有对其他资源发出请求但该资源被其他进程占用此时请求阻塞而且这个进程不会释放自己已经占有的资源不可剥夺条件进程获得资源只能自己释放不可剥夺环路等待条件若干进程之间形成一种头尾相接等待资源关系解决资源一次性分配从而解决请求保持的问题可剥夺资源当进程新的资源未得到满足时释放已有的资源资源有序分配资源按序号递增进程请求按递增请求释放则相反单核机械上写多线程程序是否考虑加锁为什么需要因为线程锁只要是用来实现线程的同步和通信在抢占是操作系统中通常为每个线程分配一个时间片当某个线程时间片耗尽时操作系统会将其挂起然后运行另一个线程如果这两个线程共享某些数据不使用线程锁的前提下可能会导致共享数据修改引起冲突互斥锁机制互斥锁和读写锁的区别互斥锁机制用于保证在任何时刻都只能有一个线程访问该对象当获取锁操作失败时线程会进入睡眠等待锁释放时被唤醒互斥锁和读写锁读写锁区分读者和写者而互斥锁不区分互斥锁同一时间只允许一个线程访问该对象无论读写读写锁同一时间内只允许一个写者但是允许多个读者同时读对象函数获取锁而函数释放锁可以通过代码示例来理解互斥锁和读写锁的使用区别互斥锁写入共享数据读取共享数据互斥锁不区分读写都需要先然后操作数据读写锁写入读取读写锁允许多个线程同时读取但只允许一个线程写入使用场景如果共享数据需要频繁写入使用互斥锁如果共享数据主要为读操作偶尔写入则读写锁更高效通过代码示例可以更直观地看到两种锁的区别和适用场景在编程时需要根据具体情况选择合适的锁考题使用多线程的思路实现快速排序使用多线程可以对快速排序算法进行优化步骤如下在主线程中生成一个随机数组进行排序定义一个多线程快排函数包含数组下标作为参数在函数内部通过一个将数组分成两部分左边都比小右边都比大对两边子数组再递归调用多线程快排函数每次调用都用一个新线程去执行注意对子数组长度做判断如果小于某个阈值就直接单线程排序等待所有线程执行结束排序完成数组大小子数组大小阈值单线程快排实现子数组长度为则返回选择中间作为左右指针实现分区递归排序左右分区多线程快排小数组以并行分割随机初始化数组调用多线程快排说说什么是信号量有什么作用由于信号量只能进行两种操作等待和发送信号即和操作如果的值大于零就给它减如果它的值为零就挂起该进程的执行信号量的值为正进程获得该资源的使用权进程将信号量减表示它使用了一个资源单位操作如果有其他进程因等待而被挂起就让它恢复运行如果没有进程因等待而挂起就给它加若此时信号量的值为则进程进入挂起状态直到信号量的值大于若进程被唤醒则返回至第一步作用用于多进程对共享数据对象的读取它主要是用来保护共享资源信号量也属于临界资源使得资源在一个时刻只有一个进程独享代码示例初始化信号量为共享的计数变量获取信号量实现互斥访问共享变量释放信号量获取信号量实现互斥已累加到重置为释放信号量分析线程使用信号量实现对的互斥访问当累加到时线程获取信号量同步访问变量并置两个线程通过获取释放信号量实现了对共享变量的互斥与同步信号量起到了线程间的控制作用以上代码通过注释和分析展示了信号量的互斥与同步作用信号量是多线程编程一个非常重要的同步机制进程线程的中断切换的过程是怎样的上下文切换指的是内核操作系统的核心在上对进程或者线程进行切换进程上下文切换保护被中断进程的处理器现场信息修改被中断进程的进程控制块有关信息如进程状态等把被中断进程的进程控制块加入有关队列选择下一个占有处理器运行的进程根据被选中进程设置操作系统用到的地址转换和存储保护信息根据被选中进程恢复处理器现场多线程和单线程有什么区别多线程编程要注意什么多线程加锁需要注意什么多线程和单线程编程主要有以下区别单线程程序只有一个执行序列多线程程序有多个执行流同时执行多线程可以有效利用多核提高程序执行效率单线程无法利用多核特性多线程需要处理线程同步和竞争条件编程复杂度更高多线程程序内存开销更大调试更困难多线程编程需要注意共享资源访问需要加锁同步防止竞争线程安全避免数据竞争和死锁合理设计任务分工避免过多线程调度开销注意线程间同步和通信消息传递等多线程加锁需要注意锁的粒度不要锁定过多资源尽量减少临界区代码缩小锁定范围避免死锁加锁顺序要一致使用读写锁分离读写操作利用线程间同步原语如信号量条件变量避免重复加锁和遗漏解锁综上多线程编程可以利用多核但也面临更多问题需要注意设计方式正确使用同步原语才能发挥其优势为什么要创建线程池线程池的设计思路线程池中线程的数量由什么确定原因创建和销毁线程的花销是比较大的这些时间可能比处理业务时间还要长这样频繁的创建和销毁线程再加上业务工作的线程消耗系统资源的时间可能导致系统资源不足线程池可以提升系统效率实现线程池步骤设置一个生产者消费队列作为临时资源初始化个线程并让其运行起来加锁去队列里去任务运行当任务队列为空时所有线程阻塞当生产者队列来了一个任务后先对队列加锁把任务挂到队列上然后使用条件变量通知阻塞中的线程来处理实现创建任务队列类的申明定义任务结构体任务队列添加任务取出一个任务获取当前队列中任务个数互斥锁任务队列作者苏丙榅链接来源爱编程的大丙著作权归作者所有商业转载请联系作者获得授权非商业转载请注明出处类的定义作者苏丙榅链接来源爱编程的大丙著作权归作者所有商业转载请联系作者获得授权非商业转载请注明出处线程池类声明添加任务获取忙线程的个数获取活着的线程个数工作的线程的任务函数管理者线程的任务函数作者苏丙榅链接来源爱编程的大丙著作权归作者所有商业转载请联系作者获得授权非商业转载请注明出处类定义实例化任务队列初始化线程池根据线程的最大上限给线程数组分配内存失败初始化初始化互斥锁条件变量创建线程根据最小线程个数创建线程创建子线程创建管理者线程个销毁管理者线程唤醒所有消费者线程添加任务不需要加锁任务队列中有锁唤醒工作的线程工作线程任务函数一直不停的工作访问任务队列共享资源加锁判断任务队列是否为空如果为空工作线程阻塞阻塞线程解除阻塞之后判断是否要销毁线程判断线程池是否被关闭了从任务队列中取出一个任务工作的线程线程池解锁执行任务任务处理结束管理者线程任务函数如果线程池没有关闭就一直检测每隔检测一次取出线程池中的任务数和线程数量取出工作的线程池数量创建线程当前任务个数存活的线程数存活的线程数最大线程个数线程池加锁销毁多余的线程忙线程存活的线程数目存活的线程数最小线程数量线程退出作者苏丙榅链接来源爱编程的大丙著作权归作者所有商业转载请联系作者获得授权非商业转载请注明出处线程的数量并发并行有关如果是密集型应用则线程池大小设置为数目如果是密集型应用则线程池大小设置为数目最佳线程数目线程等待时间与线程时间之比数目所以线程等待时间所占比例越高需要越多线程线程时间所占比例越高需要越少线程说说多路复用技术有哪些区别是什么常见的多路转接方式有每次调用都需要把集合从用户态拷贝到内核态这个开销在很多时会很大而保证了每个在整个过程中只会拷贝一次每次调用都需要在内核遍历传递进来的所有才知道哪些是被设置了而只需要轮询一次集合同时查看就绪链表中有没有就绪的就可以了设置监听的集合不能被重新使用支持的文件描述符数量太小了默认是而没有这个限制它所支持的上限是最大可以打开文件的数目这个数字一般远大于为什么高效拷贝查询返回实现需要自己不断轮询所有集合直到设备就绪期间可能要睡眠和唤醒多次交替而只要判断一下就绪链表是否为空就行了这节省了大量的时间每次调用都要把集合从用户态往内核态拷贝一次并且要把当前进程往设备等待队列中挂一次而只要一次拷贝而且把当前进程往等待队列上挂也只挂一次这也能节省不少的开销当我们调用函数返回的不是实际的描述符而是一个代表就绪描述符数量的值这个时候需要去指定的一个数组中定义的结构体依次取得相应数量的描述符即可这个数组里面保存的都是可以的文件描述符而不需要遍历扫描所有的描述符因此这里的时间复杂度是这里和的区别是返回的也是可用的数量但是并没有告诉你可用的文件描述符是谁你必须得遍历全部的文件描述符才知道是那些就绪了最大的优点就在于它只管就绪的描述符而跟描述符的总数无关调用创建一个实例就会在内核中创建用来存放监听文件描述符的红黑树另一个是就绪表说说多路复用技术有哪些区别是什么都是多路复用的机制多路复用就是通过一种机制可以监视多个文件描述符一旦某个文件描述符就绪一般是读就绪或者写就绪能够通知应用程序进行相应的读写操作的工作模式为和即水平触发和边缘触发默认是水平触发区别水平触发一但文件描述符就绪后就会一直通知你去读取数据直到你把数据读完边沿触发一会通知你一次有数据可读所以你必须得把数据读完不然会在再通知你数据可读下次再来数据的时候才会再通知你必须配合无阻塞即为非阻塞读数据数据如果使用阻塞就到导致重新阻塞无法继续监听其他文件描述符函数使用灵魂三步曲使用原理首先使用监听的最大数量把需要监听的文件描述符添加到里面去需要设置监听那个文件描述符什么类型比如监听的是可写还是可读使用结构体设置参数说明其中表示添加相反的还有删除是个结构体这个结构体可以用来设置需要监听的文件描述符其中可以设置为表示被监听的文件为可读时发生可写时发生等待监听的文件描述符发生是结构体用来已经保存可读或可写的文件描述符用户只需通过判断该结构体中的即可知道是否为需要的文件描述符表示阻塞等待使用例子使用监听服务器的客户端创建套接字绑定端口监听创建的文件描述符或者说句柄设置监听的文件描述符这里主要是创建的套接字等待文件描述符可用返回值为可用的文件描述符数量判断可用的文件描述符是否为创建的套接字如果是则表示有新客户连接服务器需要接收连接并把通信的设置到监听里面去如果判断不是创建的套接字则表示是客户端的那么此时需要去处理客户端的信息比如读取客户端发上来的数据或者发数据给客户端又或者创建线程处理复杂任务代码如下创建套接字绑定监听用来写进监听用来保存监听到的监听可读创建对象给添加到集合表示阻塞等待可读监听的保存到返回值为可读个数判断是否为是表示有新客户端连接处理接受连接保存通信到监听集合客户端连接成功给添加客户端通信的表示是客户端的通信可用判断是否为可读退出删除掉线的文件描述符收到来自的信息函数的使用函数原型参数表示最大的文件描述符号之所以加因为内核遍历哪些文件描述符可用时是从开始比如最大文件描述符为那么就需要遍历次才能遍历到文件描述符文件描述符可读的集合当调用函数之后比如监听的可读文件描述符总共有个但只有文件描述符可读时该函数会把里的其他文件描述符置所以要想每次都监听全部的文件描述符就需要事先保存下来设置阻塞监听时间为时阻塞为时不阻塞注意不需要监听的集合只需要设置为即可清除监听集合中的文件描述符清除之后不再监听判断监听集合中文件描述符是否可用设置文件描述符到监听集合中监听清除所有的文件描述符该函数只能监听个文件描述符因为个字节位每一位表示一个文件描述符工作流程用户设置需要监听的文件描述符到监听的集合设置文件描述符到监听集合中监听调用函数监听文件描述符集合此时用会把需要监听的集合拷贝到内核监听到集合中文件描述符可用时把监听的集合从内核拷贝到用户内核自己完成判断集合中是否有自己想要的文件描述符判断监听集合中文件描述符是否可用创建套接字绑定监听监听集合清空集合设置集合设置监听个数保存集合因为当有文件有可读或写异常时会把其他文件描述符删掉留下可用的文件描述符监听有可读文件描述符判断是否为是表示新客户端连接判断哪个通信是没用过的因为当客户端退出后那个位置就为接受链接打印连接的客户端客户端连接成功把上线的客户端的文件描述符写入集合修改监听的最大个数表示是通信描述符的清除判断是哪个通信文件描述符接收来自客户端信息判断是否为退出客户端退出关闭通信文件描述符从监听集合中清除通信文件符文件描述符置收到客户的信息打印信息有名管道的通信步骤有名管道是一种进程间通信机制可以实现不同进程之间的数据传递有名管道的使用步骤创建管道指定管道名称这将创建一个指定名字的有名管道打开管道打开读端打开写端通过以只读或只写方式打开管道的两端写入管道写入数据一个进程可以通过写入管道从管道读取从管道读取数据另一个进程可以通过读取数据关闭管道数据传输完成后关闭管道的文件描述符通过这种机制两个没有亲缘关系的进程可以通过有名管道进行通信信号的常见知识信号的作用用于通知接收进程有某种事件发生除了用于进程间通信还可以发送信号给自己常见信号常见的信号及功能如下终止进程的信号用于无条件结束进程进程无法拦截或忽略这个信号暂停进程的信号可以使进程停止运行继续运行进程的信号可以使被暂停的进程继续运行计时器报警信号可以用于进程定时发送报警通过和可以设置定时器定时到期后会给进程发送信号中断进程的信号通常通过发送可以允许进程进行清理工作后终止优雅终止进程的信号通知进程正常退出用户自定义信号可以用于进程间通信无效内存访问信号通常是程序访问了非法内存地址管道破裂信号写端进程退出但读端仍在读取管道时发送挂起进程信号通常在终端会话结束时发送给相关进程这些是在编程中常用的信号可以用来终止停止恢复进程也可以用于进程间通信需要根据具体场景选择合适的信号发送信号参数说明如果为正则将信号发送到指定的进程如果等于则被发送到调用进程的进程组中的每个进程如果等于则被发送到调用进程有权发送信号的每个进程进程除外初始返回值成功失败发送信号给进程或线程只能发送给自己对于进程该函数相当于对于线程该函数相当于进程可以对信号的操作缺省方式忽略信号捕捉信号要设置的信号类型指定的信号处理函数代表缺省处理系统默认处理方式比如终止终端代表忽略信号捕捉信号自己定义的处理方法新版本要设置的信号类型指定的信号处理函数代表缺省处理代表忽略信号捕捉信号自己定义的处理方法注意不能捕捉或忽略信号和创建定时器常用于检测网络超时参数说明为秒如果为则取消定时器返回值成功返回上个定时器的剩余时间失败返回注意一个进程只能创建一个定时器时间到就产生信号通过这个函数我们可以设计一个定时器时间到之后进程就会产生一个信号接收进程只需调用函数收信号即可比如设置闹钟信号改变信号默认处理方式进入睡眠防止闹钟时间过长还没到时间程序就运行完直到中断信号出现才有可能继续往下共享内存线程创建共享内存映射到进程地址通过映射地址操作共享内存关闭映射线程打开共享内存映射操作共享内存关闭映射说说软链接和硬链接的区别软链接和硬链接都是文件系统中的链接文件主要区别如下软链接是文件的引用它只记录了原始文件路径不占用额外空间硬链接是文件的拷贝它指向原始文件占用相同大小空间删除原文件软链接失效硬链接仍可用软链接可以跨文件系统硬链接不能跨文件系统软链接可以对目录创建链接硬链接只可对文件创建链接软链接使用绝对路径或相对路径硬链接只使用绝对路径软链接由创建硬链接由创建总结一下软链接类似的快捷方式硬链接是文件副本同时指向源文件软链接更灵活硬链接保证文件不会失效硬链接在修改原文件时更安全软链接修改原文件路径就会失效使用指令进行软连接说说静态库和动态库怎么制作及如何使用区别是什么静态库的制作编译成可执行的文件将可执行文件制作成库静态库的使用动态库的制作动态库的使用区别什么时候加载加载速度如何内存占用大小执行效率静态库代码装载的速度快执行速度略比动态库快动态库更加节省内存可执行文件体积比静态库小很多静态库是在编译时加载动态库是在运行时加载生成的静态链接库下以为后缀下以为后缀生成的动态链接库下以为后缀下以为后缀简述常见的调试命令什么是条件断点多进程下如何调试在编译的时候必须加上参数多进程下如何调试用调试子进程或者调试父进程条件断点条件以条件表达式设置断点简述系统态与用户态什么时候会进入系统态用户态进程执行自己的代码时处于用户态大部分指令都能正常执行但是不能执行特权指令访问受保护的内存空间系统态进程执行内核代码时处于系统态可以执行任何特权指令访问系统资源什么时候进入内核态系统调用主动异常设备中断为什么区分用户态和内核态在中有些指令比较危险如果用错就会导致系统崩溃比如清内存什么是页表为什么要有页表是虚拟内存的概念虚拟内存映到物理内存的映射表就是页表原因虚拟内存要和物理地址映射起来就必须要通过映射表找到物理地址如果将每一个虚拟内存的都对应到物理内存的地址每个条目最少需要字节位虚拟地址位物理地址在内存的情况下就需要的空间来存放对照表那么这张表就大得真正的物理地址也放不下了于是操作系统引入了页的概念使用个字节的映射就对应物理内存的页内存这样把全部虚拟地址映射到页表就会节省很大空间一般来说进程的虚拟地址要想找到物理地址就必须通过里面放的就是映射表通过虚拟内存的高位知道自己在映射表的位置也就是对应的物理地址的页起始位置虚拟地址的低位对应物理地址的页里面的具体地址比如中前位对应映射表的那么就会去找物理地址为起始的页表示在页中的第几个这样就可以找到具体物理地址由于映射表是个字节就映射物理地址的页即那么映射完整个物理地址之后就会节省大量空间不同进程之间的页表是不一样的简述操作系统中的实现原理底层实现当开辟的空间小于时调用函数当开辟的空间大于时调用采用的是内存池的管理方式以减少内存碎片先申请大块内存作为堆区然后将堆区分为多个内存块当用户申请内存时直接从堆区分配一块合适的空闲快采用隐式链表将所有空闲块每一个空闲块记录了一个未分配的连续的内存地址简述操作系统中的缺页中断和函数在内存分配时只是建立了进程的虚拟地址并没有分配虚拟地址对应的物理内存当进程访问这些没有建立映射关系的虚拟内存时处理器自动触发一个缺页异常引发缺页中断缺页异常后将产生一个缺页中断此时操作系统会根据页表中的外存地址在外存中找到所缺的一页将其调入内存简述的原理和使用场景原理是一种内存映射文件的方法即将一个文件或者其它对象映射到进程的地址空间实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系实现这样的映射关系后进程就可以采用指针的方式读写操作这一段内存而系统会自动回写脏页面到对应的文件磁盘上即完成了对文件的操作而不必再调用等系统调用函数相反内核空间对这段区域的修改也直接反映用户空间从而可以实现不同进程间的文件共享为什么使用虚拟内存扩大地址空间每个进程独占一个空间虽然真实物理内存没那么多内存保护防止不同进程对物理内存的争夺和践踏可以对特定内存地址提供写保护防止恶意篡改可以实现内存共享方便进程通信可以避免内存碎片虽然物理内存可能不连续但映射到虚拟内存上可以连续用户空间和内核空间的通信方式使用内核提供的函数文件系统系统调用中断的响应执行流程听说过顶半部和底半部吗接收中断保存中断上下文跳转到中断的处理函数执行中断上半部分执行中断的下半部分恢复中断的上下文顶半部执行一般是比较紧急的任务比如清中断下半部执行的一些不太紧急的人任务可以节省中断处理时间是什么缩小版的系统常用命令工具箱什么是根文件系统是内核启动时所挂载的第一个文件系统内核代码映像文件保存在根文件系统中自旋锁是什么信号量是什么二者有什么区别自旋锁不会进入睡眠自旋锁只有两个状态锁定和解锁在锁定期间其他进程我是不能进行访问资源比如想访问只能在外面等到解锁之后才能访问如果等待的时间过长那么就要考虑使用互斥锁信号量会进入睡眠信号量是个计数器用来统计资源的可用次数比如进程想使用资源当资源可用的是时候就会去通知而不是让在哪里等着不会一直占用这样就可以提高系统的执行效率区别信号量会让等待信号的的进程进入睡眠所以信号量适用于锁会被长时间持有的情况自旋锁会一直在哪里循环判断所是否可用占用极高所以不适用长时间持有所的情况自旋锁禁止处理器抢占信号量允许这也就是为什么自旋锁不能睡眠的原因如果自旋锁睡眠那么就无法通过抢占唤醒睡眠的自旋锁信号量不能用于中断中因为信号量会引起休眠中断不能睡眠自旋锁可以为什么堆的空间不是连续的堆内存的管理只要是靠链表来维护已用和空闲的内存当我们申请堆内存空间时会在空间里面找到一个满足要求的内存当我们释放掉大的内存空间时这些大块空间就会和那些零散的空间合并成一个空间快内核的组成部分进程内存管理文件系统网络接口系统的组成部分内核文件系统应用程序线程的同步和互斥的区别和联系同步是指按照一定顺序执行同步里面包含了互斥互斥是指一个资源只能出现一个进程进行访问但是互斥没办法按照顺序执行是无序的常见命令解压压缩命令是操作的命令后缀是压缩压缩包的命令压缩文件解压缩文件查看内存查看修改文件权限查看内核查看栈大小进程终止进程终止分为正常和异常特殊进程下有个特殊的进程进程进程是由系统自动创建运行在内核态进程进程是由创建运行在用户空间其父进程就是内核线程负责内核线程的创建工作其父进程就是多线程中使用较多的函数获得父进程互斥量初始化和如果调用和向指定条件变量发送信号时若无任何线程等待该条件变量这个信号也就会不了了之驱动里面为什么需要并发和互斥并发是指多个单元同时执行这样就会是共享内存的数据被修改形成一种竞争所以我们需要互斥让一个时间段只能一个单元对数据访问像自旋锁信号量都是可用的操作软中断和硬中断的区别和的区别中子进程修改全局变量会影响父进程的全局变量注意第二点什么是虚拟内存虚拟内存是一种内存管理技术之所以有这个虚拟内存主要是为了扩张内存因为我们的这个代码数据什么都是存在硬盘中的而是没办法直接去拿硬盘的数据必须借助内存但是这个内存是有限的所以但内存不够的时候就会把一部分这个硬盘作为虚拟内存这样就可以读取虚拟内存的数据并发编程的三个概念在并发编程中我们通常会遇到以下三个问题原子性问题可见性问题有序性问题原子性即一个操作或者多个操作要么全部执行并且执行的过程不会被任何因素打断要么就都不执行可见性是指当多个线程访问同一个变量时一个线程修改了这个变量的值其他线程能够立即看得到修改的值有序性即程序执行的顺序按照代码的先后顺序执行同步和异步同步一般是指阻塞等待异步一般是不需要等待比如你发送数据到服务器那么就不需要等待直接去干别的事一般来说异步的效率高于同步',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-08-18 16:31:38',
  postMainColor: '',
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#18171d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#f7f9fe')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(e => {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 7.0.0"></head><body data-type="anzhiyu"><div id="web_bg"></div><div id="an_music_bg"></div><div id="loading-box" onclick="document.getElementById(&quot;loading-box&quot;).classList.add(&quot;loaded&quot;)"><div class="loading-bg"><img class="loading-img nolazyload" alt="加载头像" src="https://npm.elemecdn.com/anzhiyu-blog-static@1.0.4/img/avatar.jpg"/><div class="loading-image-dot"></div></div></div><script>const preloader = {
  endLoading: () => {
    document.getElementById('loading-box').classList.add("loaded");
  },
  initLoading: () => {
    document.getElementById('loading-box').classList.remove("loaded")
  }
}
window.addEventListener('load',()=> { preloader.endLoading() })
setTimeout(function(){preloader.endLoading();},10000)

if (true) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.10/progress_bar/progress_bar.css"/><script async="async" src="https://cdn.cbd.int/pace-js@1.2.4/pace.min.js" data-pace-options="{ &quot;restartOnRequestAfter&quot;:false,&quot;eventLag&quot;:false}"></script><div class="post" id="body-wrap"><header class="not-top-img" id="page-header"><nav id="nav"><div id="nav-group"><span id="blog_name"><div class="back-home-button"><i class="anzhiyufont anzhiyu-icon-grip-vertical"></i><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div></div><a id="site-name" href="/" accesskey="h"><div class="title">宁康同学</div><i class="anzhiyufont anzhiyu-icon-house-chimney"></i></a><div id="he-plugin-simple"></div><script>var WIDGET = {
  "CONFIG": {
    "modules": "0124",
    "background": "2",
    "tmpColor": "FFFFFF",
    "tmpSize": "16",
    "cityColor": "FFFFFF",
    "citySize": "16",
    "aqiColor": "E8D87B",
    "aqiSize": "16",
    "weatherIconSize": "24",
    "alertIconSize": "18",
    "padding": "10px 10px 10px 10px",
    "shadow": "0",
    "language": "auto",
    "borderRadius": "20",
    "fixed": "true",
    "vertical": "top",
    "horizontal": "left",
    "left": "20",
    "top": "7.1",
    "key": "df245676fb434a0691ead1c63341cd94"
  }
}
</script><link rel="stylesheet" href="https://widget.qweather.net/simple/static/css/he-simple.css?v=1.4.0"/><script src="https://widget.qweather.net/simple/static/js/he-simple.js?v=1.4.0"></script></span><div class="mask-name-container"><div id="name-container"><a id="page-name" href="javascript:anzhiyu.scrollToDest(0, 500)">PAGE_NAME</a></div></div><div id="menus"><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div></div><div id="nav-right"><div class="nav-button only-home" id="travellings_button" title="随机前往一个开往项目网站"><a class="site-page" onclick="anzhiyu.totraveling()" title="随机前往一个开往项目网站" href="javascript:void(0);" rel="external nofollow" data-pjax-state="external"><i class="anzhiyufont anzhiyu-icon-train"></i></a></div><div class="nav-button" id="randomPost_button"><a class="site-page" onclick="toRandomPost()" title="随机前往一个文章" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-dice"></i></a></div><input id="center-console" type="checkbox"/><label class="widget" for="center-console" title="中控台" onclick="anzhiyu.switchConsole();"><i class="left"></i><i class="widget center"></i><i class="widget right"></i></label><div id="console"><div class="console-card-group-reward"><ul class="reward-all console-card"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" alt="微信" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" alt="支付宝" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png"/></a><div class="post-qr-code-desc">支付宝</div></li></ul></div><div class="console-card-group"><div class="console-card-group-left"><div class="console-card" id="card-newest-comments"><div class="card-content"><div class="author-content-item-tips">互动</div><span class="author-content-item-title"> 最新评论</span></div><div class="aside-list"><span>正在加载中...</span></div></div></div><div class="console-card-group-right"><div class="console-card tags"><div class="card-content"><div class="author-content-item-tips">兴趣点</div><span class="author-content-item-title">寻找你感兴趣的领域</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 1.05rem;">C++<sup>7</sup></a><a href="/tags/C-C/" style="font-size: 1.05rem;">C/C++<sup>1</sup></a><a href="/tags/Carla/" style="font-size: 1.05rem;">Carla<sup>1</sup></a><a href="/tags/Linux%E5%86%85%E6%A0%B8/" style="font-size: 1.05rem;">Linux内核<sup>1</sup></a><a href="/tags/Linux%E7%BD%91%E7%BB%9C/" style="font-size: 1.05rem;">Linux网络<sup>1</sup></a><a href="/tags/Python/" style="font-size: 1.05rem;">Python<sup>1</sup></a><a href="/tags/Socket/" style="font-size: 1.05rem;">Socket<sup>1</sup></a><a href="/tags/TCP-IP/" style="font-size: 1.05rem;">TCP/IP<sup>1</sup></a><a href="/tags/UDP/" style="font-size: 1.05rem;">UDP<sup>1</sup></a><a href="/tags/Vector/" style="font-size: 1.05rem;">Vector<sup>1</sup></a><a href="/tags/%E4%BF%A1%E4%BB%BB%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">信任管理<sup>1</sup></a><a href="/tags/%E4%BF%A1%E8%AA%89%E8%AF%84%E4%BC%B0/" style="font-size: 1.05rem;">信誉评估<sup>1</sup></a><a href="/tags/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/" style="font-size: 1.05rem;">入侵检测<sup>1</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" style="font-size: 1.05rem;">内存分配<sup>1</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 1.05rem;">内存管理<sup>1</sup></a><a href="/tags/%E5%A0%86/" style="font-size: 1.05rem;">堆<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 1.05rem;">多线程<sup>4</sup></a><a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 1.05rem;">容器<sup>1</sup></a><a href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">强化学习<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 1.05rem;">操作系统<sup>4</sup></a><a href="/tags/%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B/" style="font-size: 1.05rem;">攻击检测<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/" style="font-size: 1.05rem;">数据共享<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 1.05rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 1.05rem;">机器学习<sup>1</sup></a><a href="/tags/%E6%A0%88/" style="font-size: 1.05rem;">栈<sup>1</sup></a><a href="/tags/%E7%A7%91%E7%A0%94/" style="font-size: 1.05rem;">科研<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 1.05rem;">算法<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 1.05rem;">网络编程<sup>1</sup></a><a href="/tags/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/" style="font-size: 1.05rem;">翻转链表<sup>1</sup></a><a href="/tags/%E8%BD%A6%E8%81%94%E7%BD%91/" style="font-size: 1.05rem;">车联网<sup>2</sup></a><a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 1.05rem;">链表<sup>1</sup></a></div></div><hr/></div></div><div class="console-card history"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-box-archiv"></i><span>文章</span></div><div class="card-archives"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-archive"></i><span>归档</span></div><ul class="card-archive-list"><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2024/04/"><span class="card-archive-list-date">四月 2024</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">20</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/11/"><span class="card-archive-list-date">十一月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/08/"><span class="card-archive-list-date">八月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">7</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/07/"><span class="card-archive-list-date">七月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li><li class="card-archive-list-item"><a class="card-archive-list-link" href="/archives/2023/06/"><span class="card-archive-list-date">六月 2023</span><div class="card-archive-list-count-group"><span class="card-archive-list-count">2</span><span>篇</span></div></a></li></ul></div><hr/></div></div></div><div class="button-group"><div class="console-btn-item"><a class="darkmode_switchbutton" title="显示模式切换" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-moon"></i></a></div><div class="console-btn-item" id="consoleHideAside" onclick="anzhiyu.hideAsideBtn()" title="边栏显示控制"><a class="asideSwitch"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></a></div><div class="console-btn-item" id="consoleMusic" onclick="anzhiyu.musicToggle()" title="音乐开关"><a class="music-switch"><i class="anzhiyufont anzhiyu-icon-music"></i></a></div></div><div class="console-mask" onclick="anzhiyu.hideConsole()" href="javascript:void(0);"></div></div><div class="nav-button" id="nav-totop"><a class="totopbtn" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i><span id="percent" onclick="anzhiyu.scrollToDest(0,500)">0</span></a></div><div id="toggle-menu"><a class="site-page" href="javascript:void(0);" title="切换"><i class="anzhiyufont anzhiyu-icon-bars"></i></a></div></div></div></nav></header><main id="blog-container"><div class="layout" id="content-inner"><div id="post"><div id="post-info"><div id="post-firstinfo"><div class="meta-firstline"><a class="post-meta-original">原创</a><span class="post-meta-categories"><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-inbox post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/" itemprop="url">面试八股文</a></span><span class="article-meta tags"><a class="article-meta__tags" href="/tags/C/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>C++</span></a><a class="article-meta__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>操作系统</span></a><a class="article-meta__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>多线程</span></a><a class="article-meta__tags" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" tabindex="-1" itemprop="url"> <span> <i class="anzhiyufont anzhiyu-icon-hashtag"></i>内存管理</span></a></span></div></div><h1 class="post-title" itemprop="name headline">面试八股文——操作系统</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="anzhiyufont anzhiyu-icon-calendar-days post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" itemprop="dateCreated datePublished" datetime="2023-08-06T03:41:03.000Z" title="发表于 2023-08-06 11:41:03">2023-08-06</time><span class="post-meta-separator"></span><i class="anzhiyufont anzhiyu-icon-history post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" itemprop="dateCreated datePublished" datetime="2023-08-18T08:31:38.048Z" title="更新于 2023-08-18 16:31:38">2023-08-18</time></span></div><div class="meta-secondline"><span class="post-meta-separator">       </span><span class="post-meta-position" title="作者IP属地为长沙"><i class="anzhiyufont anzhiyu-icon-location-dot"></i>长沙</span></div></div></div><article class="post-content" id="article-container" itemscope itemtype="http://example.com/2023/08/06/2023-08-6-%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><header><a class="post-meta-categories" href="/categories/%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87/" itemprop="url">面试八股文</a><a href="/tags/C/" tabindex="-1" itemprop="url">C++</a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" tabindex="-1" itemprop="url">操作系统</a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" tabindex="-1" itemprop="url">多线程</a><a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" tabindex="-1" itemprop="url">内存管理</a><h1 id="CrawlerTitle" itemprop="name headline">面试八股文——操作系统</h1><span itemprop="author" itemscope itemtype="http://schema.org/Person">宁康</span><time itemprop="dateCreated datePublished" datetime="2023-08-06T03:41:03.000Z" title="发表于 2023-08-06 11:41:03">2023-08-06</time><time itemprop="dateCreated datePublished" datetime="2023-08-18T08:31:38.048Z" title="更新于 2023-08-18 16:31:38">2023-08-18</time></header><h2 id="1、什么是进程？什么是线程？"><a href="#1、什么是进程？什么是线程？" class="headerlink" title="1、什么是进程？什么是线程？"></a>1、什么是进程？什么是线程？</h2><p>进程是资源分配的基本单位，他是程序执行是的一个实例，在程序运行是创建</p>
<p>线程是程序执行的最小单位，是进程的一个执行流，一个进程里包含多个线程</p>
<h2 id="2-进程、线程、协程的区别？"><a href="#2-进程、线程、协程的区别？" class="headerlink" title="2.进程、线程、协程的区别？"></a>2.进程、线程、协程的区别？</h2><p>进程是资源分配的基本单位，他是程序执行是的一个实例，在程序运行是创建</p>
<p>线程是微进程，程序执行的最小单位，是进程的一个执行流，一个进程里包含多个线程</p>
<p>协程是微线程，在子程序内部执行，可在子程序内部中断，转而执行别的子程序，在适当的时候再返回来接着执行</p>
<p>进程和线程区别：(开销问题、通信、线程（进程）之间影响)</p>
<p>\1.  进程是资源最小分配单位</p>
<p>\2.  线程是最小的执行单位，也是处理器调度的基本单位</p>
<p>\3.  <strong>进程拥有自己的独立地址空间，每启动一个进程，系统就会分配地址空间，建立数据表来维护代码段，数据段，堆栈段，进程的全局变量是不共用的，这种开销是非常大，而线程是共享进程的数据，使用相同的地址空间，因此，CPU切换一个线程的开销远小于进程的切换</strong></p>
<p>\4.  <strong>线程之间的通信更加方便，同一进程下的线程共享全局变量、静态数据、而进程间的通信需要以通信的方式IPC进行，但是线程的缺点是同步和互斥是编写多线程的难点，多进程的优点是一个进程死掉不会对另个进程有影响，而多线程只要一个线程死掉整个进程就会死掉</strong></p>
<p>\5.<strong>每个线程拥有自己的栈段和寄存器组</strong></p>
<p>线程和协程的区别：</p>
<p>\1.  协程执行效率极高：协程直接操作栈基本没有内核切换的开销，所以上下文切换非常快</p>
<p>\2.  协程不需要多线程的锁机制，因为多个线程从属一个线程，不存在同时写冲突</p>
<h2 id="3-何时使用多进程？何时使用多线程？-考虑优缺点"><a href="#3-何时使用多进程？何时使用多线程？-考虑优缺点" class="headerlink" title="3.何时使用多进程？何时使用多线程？(考虑优缺点)"></a>3.何时使用多进程？何时使用多线程？(考虑优缺点)</h2><p>对资源保护和管理要求高，不限制开销和效率使用多进程</p>
<p>要求效率高，切换频繁，使用多线程</p>
<h2 id="4-创建进程的方式？"><a href="#4-创建进程的方式？" class="headerlink" title="4.创建进程的方式？"></a>4.创建进程的方式？</h2><p>1.系统初始化，像后台进程，守护进程</p>
<p>2.一个进程开启另个进程fork（）</p>
<p>3.用户的交互式请求</p>
<p>子进程拷贝了父进程的<strong>数据段、堆、栈以及继承了父进程打开的文件描述符</strong>，父进程与子进程并<strong>不共享这些存储空间</strong>，这是子进程对父进程相应部分存储空间的完全复制，执行fork()之后，<strong>每个进程均可修改各自的栈数据以及堆段中的变量，而并不影响另一个进程</strong></p>
<p><strong>如果是vfork的话就会有影响</strong></p>
<p>在 Unix-like 系统中，fork() 系统调用用于创建一个新的进程。新创建的进程是原进程的一个副本，我们通常将原进程称为父进程，新创建的进程称为子进程。fork() 函数在父进程中返回新创建的子进程的进程 ID，在子进程中返回 0。</p>
<p>因此，pid &#x3D;&#x3D; 0 的情况是在子进程中发生的。这个特性常常被用来在父进程和子进程中执行不同的代码，例如：</p>
<p> 在 Unix-like 系统（如 Linux）中，我们通常使用 <code>fork()</code> 和 <code>exec()</code> 系统调用来创建新的进程。以下是一个简单的示例，这个程序会创建一个新的进程并执行 <code>/bin/ls</code> 命令（列出当前目录的内容）：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;Fork failed\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 在子进程中执行 /bin/ls</span></span><br><span class="line">        execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;/bin/ls&quot;</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">// 父进程等待子进程结束</span></span><br><span class="line">        wait(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child process finished\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在这段代码中，我们首先调用 <code>fork()</code> 创建一个新的进程。新创建的子进程是父进程的一个复制品，它们的区别在于 <code>fork()</code> 的返回值。在父进程中，<code>fork()</code> 返回的是新创建的子进程的 PID，而在子进程中，<code>fork()</code> 返回 0。</p>
<p>然后我们检查 <code>fork()</code> 的返回值以确定我们当前在哪个进程中。如果我们在子进程中，我们就调用 <code>execl()</code> 来执行 <code>/bin/ls</code>。如果我们在父进程中，我们就调用 <code>wait()</code> 等待子进程结束。</p>
<p>注意，上面的代码中并没有处理错误。在实际的程序中，你需要检查 <code>fork()</code> 和 <code>execl()</code> 的返回值，并适当地处理可能出现的错误。</p>
<h2 id="5-进程有几种状态？"><a href="#5-进程有几种状态？" class="headerlink" title="5.进程有几种状态？"></a>5.进程有几种状态？</h2><h2 id="三大基本状态："><a href="#三大基本状态：" class="headerlink" title="三大基本状态："></a>三大基本状态：</h2><ul>
<li><p><strong>就绪态（Ready）</strong>：在这种状态下，进程已经准备好运行，正在等待操作系统调度器分配 CPU 时间片。一旦 CPU 可用，就绪状态的进程就可以转为运行状态。</p>
</li>
<li><p><strong>执行态（Running）</strong>：在这种状态下，进程正在使用 CPU 进行计算。在任何时刻（在单核 CPU 的系统中），只有一个进程可以处于运行状态。</p>
</li>
<li><p><strong>阻塞i态（Waiting &#x2F; Blocked）</strong>：在这种状态下，进程正在等待某个条件（例如 I&#x2F;O 操作的完成，如磁盘读写或网络通信）才能继续运行。当这个条件满足时，进程会转为就绪状态。</p>
</li>
</ul>
<h2 id="两种常见状态："><a href="#两种常见状态：" class="headerlink" title="两种常见状态："></a>两种常见状态：</h2><ul>
<li>创建状态</li>
<li>终止状态</li>
</ul>
<h2 id="状态转换："><a href="#状态转换：" class="headerlink" title="状态转换："></a>状态转换：</h2><p>新建 → 就绪：当进程被创建时，它首先进入新建状态。一旦操作系统完成了所有的加载和初始化工作，进程就会转换到就绪状态。</p>
<p>就绪 → 运行：当 CPU 调度器选择了一个进程进行执行，该进程就会从就绪状态变为运行状态。</p>
<p>运行 → 就绪：当 CPU 时间片耗尽或有更高优先级的进程需要运行时，当前运行状态的进程会被转换为就绪状态。</p>
<p>运行 → 等待：如果一个进程需要等待一个事件（例如，等待 I&#x2F;O 操作完成），它会从运行状态切换到等待状态。</p>
<p>等待 → 就绪：一旦等待的事件发生（例如，I&#x2F;O 完成），进程就会从等待状态切换到就绪状态。</p>
<p>运行 → 终止：如果进程已完成执行或被显式停止，它将从运行状态切换到终止状态。</p>
<blockquote>
<p>注意：在linux系统中，进程的生命周期是从执行到终止</p>
</blockquote>
<h2 id="6-进程间通信方式有哪些？"><a href="#6-进程间通信方式有哪些？" class="headerlink" title="6.进程间通信方式有哪些？"></a>6.进程间通信方式有哪些？</h2><p><strong>管道</strong>、<strong>系统IPC</strong>（包括消息队列、信号量、信号、共享内存）、<strong>套接字socket</strong></p>
<p>IPC（进程间通信）: Inter-Process Communication</p>
<ul>
<li><p><strong>管道（Pipes）</strong>：这是最早的 IPC 方法之一。它允许一个进程向另一个进程发送数据。管道特别适用于父子进程间的通信。</p>
</li>
<li><p><strong>信号（Signals）</strong>：这是一种类似于软件中断的简单通信方式，可以发送给其他进程或者同一进程的不同线程。</p>
</li>
<li><p><strong>消息队列（Message Queues）</strong>：这是一种更复杂的 IPC 方法，允许进程向消息队列中发送和接收消息。<strong>Veins平台就是这种方法。</strong></p>
</li>
<li><p><strong>共享内存（Shared Memory）</strong>：这是一种非常高效的 IPC 方法，允许多个进程读写一个共享的内存区域。</p>
</li>
<li><p><strong>套接字（Sockets）</strong>：这是一种极其强大的通信工具，可以用于在运行在同一台机器或者不同机器上的进程之间进行通信。</p>
</li>
<li><p><strong>信号量（Semaphores）</strong>：虽然信号量主要用于同步，但它们也可以用于进程间通信，特别是在关于共享资源的问题上。</p>
</li>
</ul>
<blockquote>
<p>共享内存：共享内存就是映射一段能被其他进程访问的内存，这段共享内存有一个进程创建，但多个进程都可以访问，共享内存是最快的IPC，它往往配合其他通信机制使用，如：信号量来实现同步和通信 </p>
</blockquote>
<blockquote>
<p>原理：开辟一个物理内存空间，各个进程物理地址映射到自己的虚拟地址空间，通过虚拟地址就可以直接访问，进而实现数据共享，共享内存是最快的通信方式，因为少了数据的拷贝</p>
</blockquote>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> shmid=<span class="built_in">shmget</span>(key,size,IPC_CREAT);<span class="comment">//1.开辟共享内存</span></span><br><span class="line">addr=<span class="built_in">shmat</span>(shmid,<span class="literal">NULL</span>,<span class="number">0</span>);<span class="comment">//2.映射到进程虚拟地址</span></span><br><span class="line"><span class="built_in">memcpy</span>(addr,buf,<span class="built_in">sizeof</span>(buf));<span class="comment">//3.操作数据</span></span><br><span class="line"><span class="type">int</span> ret=<span class="built_in">shmdt</span>(addr);<span class="comment">//解除映射</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>套接字:它可用于不同机器之间的进程通信</p>
<p>其中信号量、信号、消息队列可以用来同步</p>
</blockquote>
<h2 id="7-进程间通信的选择"><a href="#7-进程间通信的选择" class="headerlink" title="7.进程间通信的选择"></a>7.进程间通信的选择</h2><p>管道通信主要是应用在进程间护法短小、频率很高的消息 </p>
<p>共享内存主要是在接进程间共享数据庞大、读写频繁的数据(因为是把物理地址映射到进程)</p>
<p>其他考虑socket</p>
<h2 id="8、什么是僵尸进程、孤儿进程、守护进程？"><a href="#8、什么是僵尸进程、孤儿进程、守护进程？" class="headerlink" title="8、什么是僵尸进程、孤儿进程、守护进程？"></a>8、什么是僵尸进程、孤儿进程、守护进程？</h2><p>僵尸进程：一个进程使用fork出一个子进程，如果子进程退出，但是父进程没有使用        wait或者waitpid函数回收子进程的资源，那么该进程就是僵尸进程</p>
<p>孤儿进程：是指父进程异常退出，而子进程还没退出，那么子进程就会被1号进程(init)收养</p>
<p>守护进程：是指后台进程，有意把父进程先结束，然后被1号进程收养。例如，Web 服务器、打印服务器、数据库服务器等都是以守护进程的形式运行的。它们在后台运行，独立于任何用户终端，并提供特定的服务。守护进程通常在系统启动时启动，并在系统关闭时关闭。</p>
<h2 id="9-僵尸进程有什么危害？"><a href="#9-僵尸进程有什么危害？" class="headerlink" title="9.僵尸进程有什么危害？"></a>9.僵尸进程有什么危害？</h2><p>僵尸进程的进程号并不会被释放，但是系统的进程号是有限的，如果出现大量僵尸进程就会导致系统无进程号可用就无法产生新进程</p>
<p>如何杀死僵尸进程：</p>
<p>可以通过杀死其父进程来结束僵尸进程</p>
<h2 id="10-线程间通信方法有哪些？"><a href="#10-线程间通信方法有哪些？" class="headerlink" title="10.线程间通信方法有哪些？"></a>10.线程间通信方法有哪些？</h2><p>临界区、互斥量、信号量、事件、条件变量、读写锁</p>
<p>临界区：每个线程访问临界资源的那段代码叫临界区，每次只允许一个线程进入临界区，进入后其他线程无法进入</p>
<p>互斥量：采用互斥对象机制，只有拥有互斥对象的线程才可以访问</p>
<p>信号量：计数器，允许多个线程同时访问统一资源</p>
<p>条件变量：通过条件变量通知操作的方式保持多线程同步</p>
<p>读写锁：读写锁和互斥量类似，但互斥量要么是锁住状态，要么就是不加锁状态。读写锁一次只允许一个线程写，但允许一次多个线程读，这样效率就比互斥锁要高</p>
<h2 id="11-说说线程，进程同步方式有哪些？"><a href="#11-说说线程，进程同步方式有哪些？" class="headerlink" title="11.说说线程，进程同步方式有哪些？"></a>11.说说线程，进程同步方式有哪些？</h2><p>线程间的同步方式包括互斥锁、信号量、条件变量、读写锁</p>
<h2 id="12-什么是内核线程和用户线程？"><a href="#12-什么是内核线程和用户线程？" class="headerlink" title="12.什么是内核线程和用户线程？"></a>12.什么是内核线程和用户线程？</h2><p><strong>用户线程是由用户进行管理，用户线程的创建、调度、同步和销毁全又库函数在用户空间完成，不需要内核的帮助，这种线程开销是比较小的</strong></p>
<p><strong>内核线程由操作系统创建和销毁</strong></p>
<p>12.如何实现守护进程？</p>
<p>\1.  创建子进程，终止父进程</p>
<p>\2.  调用setsid创建一个新会话</p>
<p>\3.  将当前目录更改为根目录</p>
<p>\4.  重设文件权限掩码，文件权限掩码是指屏蔽掉文件权限的对应为</p>
<p>\5.  关闭不再需要的文件描述符</p>
<h2 id="12-进程调度算法即策略有哪些？"><a href="#12-进程调度算法即策略有哪些？" class="headerlink" title="12.   进程调度算法即策略有哪些？"></a>12.   进程调度算法即策略有哪些？</h2><p>\1.  先来先服务</p>
<p>\2.  短作业优先调度</p>
<p>\3.  高优先级优先</p>
<p>\4.  时间片论</p>
<p>\5.  多级反馈队列</p>
<h2 id="14-有抢占式和非抢占式的区别"><a href="#14-有抢占式和非抢占式的区别" class="headerlink" title="14.有抢占式和非抢占式的区别"></a>14.有抢占式和非抢占式的区别</h2><p><strong>非抢占式优先权算法 在这种方式下，系统一旦把处理机分配给就绪队列中优先权最高的进程后，该进程便一直执行下去，直至完成</strong></p>
<p><strong>抢占式优先权调度算法 在这种方式下，系统同样是把处理机分配给优先权最高的进程，使之执行。但在其执行期间，只要又出现了另一个其优先权更高的进程，进程调度程序就立即停止当前进程(原优先权最高的进程)的执行，重新将处理机分配给新到的优先权最高的进程</strong></p>
<h2 id="15-并发和并行"><a href="#15-并发和并行" class="headerlink" title="15.并发和并行"></a>15.并发和并行</h2><p><strong>并发是对于单个cpu来说，在一个是个只能一个进程运行，但是线程的切换时间则是减少到纳秒数量级，多个任务不停的来回切换</strong></p>
<p><strong>并行是对于多个CPU来说，多个进程同时运行</strong></p>
<p>区别;<strong>并行的”同时”是同一时刻可以多个任务在运行(处于running)，并发的”同时”是经过不同线程快速切换</strong></p>
<h2 id="16-进程间的通信中的管道通信实现原理是什么："><a href="#16-进程间的通信中的管道通信实现原理是什么：" class="headerlink" title="16.进程间的通信中的管道通信实现原理是什么："></a>16.进程间的通信中的管道通信实现原理是什么：</h2><p><strong>操作系统在内核中开辟一块缓冲区(称为管道)用于通信</strong></p>
<p>编程步骤：</p>
<p>\1.  父进程调用pipe开辟管道,得到两个文件描述符指向管道的两端</p>
<p>\2.  父进程调用fork创建子进程,那么子进程也有两个文件描述符指向同一管道</p>
<p>\3.  父进程关闭管道读端,子进程关闭管道写端。父进程可以往管道里写,子进程可以从管道里读,<strong>管道是用环形队列实现的,数据从写端流入从读端流出,这样就实现了进程间通信</strong></p>
<hr>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;unistd.h&gt;     </span><br><span class="line">#include&lt;stdio.h&gt;     </span><br><span class="line">#include&lt;stdlib.h&gt;     </span><br><span class="line">#include&lt;string.h&gt;     </span><br><span class="line">#define INPUT  0  //读数据fd    </span><br><span class="line">#define OUTPUT 1   //发数据fd  </span><br><span class="line">     </span><br><span class="line">int main()&#123;     </span><br><span class="line">//创建管道     </span><br><span class="line">    int fd[2];     </span><br><span class="line">    pipe(fd);     </span><br><span class="line">    //创建子进程     </span><br><span class="line">    pid_t pid = fork();     </span><br><span class="line">    if (pid &lt; 0)&#123;     </span><br><span class="line">        printf(&quot;fork error!\n&quot;);     </span><br><span class="line">        exit(-1);     </span><br><span class="line">    &#125;     </span><br><span class="line">    else if (pid == 0)&#123;//执行子进程   </span><br><span class="line">        printf(&quot;Child process is starting...\n&quot;);    </span><br><span class="line">       //子进程向父进程写数据，关闭管道的读端    </span><br><span class="line">        close(fd[INPUT]);   </span><br><span class="line">        write(fd[OUTPUT], &quot;hello douya!&quot;, strlen(&quot;hello douya!&quot;));   </span><br><span class="line">        exit(0);   </span><br><span class="line">    &#125;   </span><br><span class="line">    else&#123;//执行父进程   </span><br><span class="line">        printf (&quot;Parent process is starting......\n&quot;);   </span><br><span class="line">        //父进程从管道读取子进程写的数据 ，关闭管道的写端     </span><br><span class="line">        close(fd[OUTPUT]);     </span><br><span class="line">        char buf[255];   </span><br><span class="line">        int output = read(fd[INPUT], buf, sizeof(buf));   </span><br><span class="line">        printf(&quot;%d bytes of data from child process: %s\n&quot;, output, buf);   </span><br><span class="line">    &#125;   </span><br><span class="line">    return 0;     </span><br><span class="line">&#125; </span><br></pre></td></tr></table></figure>

<h2 id="17-说说什么死锁，产生的条件，如何解决？"><a href="#17-说说什么死锁，产生的条件，如何解决？" class="headerlink" title="17.说说什么死锁，产生的条件，如何解决？"></a>17.说说什么死锁，产生的条件，如何解决？</h2><p><strong>死锁是指多个进程在执行过程中，因争夺资源而造成互相等待，此时系统产生了死锁</strong></p>
<p>产生条件：</p>
<p>\1.   互斥条件：进程对所分配的资源不允许其他进程访问，若其他进程需要访问，只能等待，知道该进程使用完毕后释放资源</p>
<p>\2.   请求保持条件：进程获得一定资源后，有对其他资源发出请求，但该资源被其他进程占用，此时请求阻塞，而且这个进程不会释放自己已经占有的资源</p>
<p>\3.   不可剥夺条件：进程获得资源，只能自己释放，不可剥夺</p>
<p>\4.   环路等待条件：若干进程之间形成一种头尾相接等待资源关系</p>
<p>解决：   </p>
<p>资源一次性分配，从而解决请求保持的问题  </p>
<p>可剥夺资源：当进程新的资源未得到满足时，释放已有的资源；</p>
<p>资源有序分配：资源按序号递增，进程请求按递增请求，释放则相反</p>
<h2 id="18-单核机械上写多线程程序，是否考虑加锁，为什么？"><a href="#18-单核机械上写多线程程序，是否考虑加锁，为什么？" class="headerlink" title="18.单核机械上写多线程程序，是否考虑加锁，为什么？"></a>18.单核机械上写多线程程序，是否考虑加锁，为什么？</h2><p><strong>需要</strong></p>
<p>因为线程锁只要是用来实现线程的同步和通信，在抢占是操作系统中，通常为每个线程分配一个时间片，当某个线程时间片耗尽时，操作系统会将其挂起，然后运行另一个线程。如果这两个线程共享某些数据，不使用线程锁的前提下，可能会导致共享数据修改引起冲突</p>
<h2 id="19-互斥锁机制，互斥锁和读写锁的区别？"><a href="#19-互斥锁机制，互斥锁和读写锁的区别？" class="headerlink" title="19.互斥锁机制，互斥锁和读写锁的区别？"></a>19.互斥锁机制，互斥锁和读写锁的区别？</h2><p>互斥锁机制：mutex，用于保证在任何时刻，都只能有一个线程访问该对象。当获取锁操作失败时，线程会进入睡眠，等待锁释放时被唤醒</p>
<p>互斥锁和读写锁：</p>
<p>（1） 读写锁区分读者和写者，而互斥 锁不区分</p>
<p>（2）互斥锁同一时间只允许一个线程访问该对象，无论读写；读写锁同一时间内只允许一个写者，但是允许多个读者同时读对象</p>
<p>函数 acquire() 获取锁，而函数 release() 释放锁</p>
<p><strong>可以通过C++代码示例来理解互斥锁和读写锁的使用区别:</strong></p>
<ol>
<li>互斥锁</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">mutex m; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  m.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="comment">// 写入共享数据</span></span><br><span class="line">  m.<span class="built_in">unlock</span>();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  m.<span class="built_in">lock</span>();</span><br><span class="line">  <span class="comment">// 读取共享数据</span></span><br><span class="line">  m.<span class="built_in">unlock</span>();  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>互斥锁不区分读写,都需要先lock然后操作数据。</p>
<ol start="2">
<li>读写锁</li>
</ol>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">shared_mutex rw;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">write_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  rw.<span class="built_in">lock</span>(); </span><br><span class="line">  <span class="comment">// 写入</span></span><br><span class="line">  rw.<span class="built_in">unlock</span>();</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">read_data</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  rw.<span class="built_in">lock_shared</span>();</span><br><span class="line">  <span class="comment">// 读取</span></span><br><span class="line">  rw.<span class="built_in">unlock_shared</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>读写锁允许多个线程同时lock_shared读取,但只允许一个线程lock写入。</p>
<ol start="3">
<li>使用场景</li>
</ol>
<p>如果共享数据需要频繁写入,使用互斥锁;</p>
<p>如果共享数据主要为读操作,偶尔写入,则读写锁更高效。</p>
<p>通过代码示例可以更直观地看到两种锁的区别和适用场景。在编程时需要根据具体情况选择合适的锁。</p>
<blockquote>
<p>考题：使用多线程的思路实现快速排序</p>
<p>使用多线程可以对快速排序算法进行优化,步骤如下:</p>
<ol>
<li><p>在主线程中生成一个随机数组进行排序</p>
</li>
<li><p>定义一个多线程快排函数,包含数组start、end下标作为参数</p>
</li>
<li><p>在函数内部,通过一个pivot将数组分成两部分,左边都比pivot小,右边都比pivot大</p>
</li>
<li><p>对两边子数组再递归调用多线程快排函数,每次调用都用一个新线程去执行</p>
</li>
<li><p>注意对子数组长度做判断,如果小于某个阈值就直接单线程排序</p>
</li>
<li><p>等待所有线程执行结束,排序完成</p>
</li>
</ol>
</blockquote>
 <figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;random&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> ARRAY_SIZE = <span class="number">1000000</span>; <span class="comment">// 数组大小</span></span><br><span class="line"><span class="type">const</span> <span class="type">int</span> THRESHOLD = <span class="number">1000</span>; <span class="comment">// 子数组大小阈值</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 单线程快排实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">quickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (end - start &lt; <span class="number">2</span>) <span class="keyword">return</span>; <span class="comment">// 子数组长度为1则返回</span></span><br><span class="line">  </span><br><span class="line">  <span class="type">int</span> pivotIndex = start + (end - start) / <span class="number">2</span>; <span class="comment">// 选择中间作为pivot</span></span><br><span class="line">  <span class="type">int</span> pivot = arr[pivotIndex];</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 左右指针,实现分区</span></span><br><span class="line">  <span class="type">int</span> i = start, j = end - <span class="number">1</span>; </span><br><span class="line">  <span class="keyword">while</span> (i &lt;= j) &#123;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] &lt; pivot) i++; </span><br><span class="line">    <span class="keyword">while</span> (arr[j] &gt; pivot) j--;</span><br><span class="line">    <span class="keyword">if</span> (i &lt;= j) &#123;  </span><br><span class="line">      <span class="built_in">swap</span>(arr[i], arr[j]);</span><br><span class="line">      i++;</span><br><span class="line">      j--;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 递归排序左右分区</span></span><br><span class="line">  <span class="keyword">if</span> (start &lt; j) <span class="built_in">quickSort</span>(arr, start, j);  </span><br><span class="line">  <span class="keyword">if</span> (end &gt; i) <span class="built_in">quickSort</span>(arr, i, end);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多线程快排</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">parallelQuickSort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; arr, <span class="type">int</span> start, <span class="type">int</span> end)</span> </span>&#123;</span><br><span class="line">  </span><br><span class="line">  <span class="comment">// 小数组 Sequential Sort</span></span><br><span class="line">  <span class="keyword">if</span> (end - start &lt; THRESHOLD) &#123; </span><br><span class="line">    <span class="built_in">quickSort</span>(arr, start, end);</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="type">int</span> pivotIndex = start + (end - start) / <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 以pivot并行分割</span></span><br><span class="line">  <span class="function">thread <span class="title">t1</span><span class="params">(parallelQuickSort, ref(arr), start, pivotIndex)</span></span>;  </span><br><span class="line">  <span class="function">thread <span class="title">t2</span><span class="params">(parallelQuickSort, ref(arr), pivotIndex + <span class="number">1</span>, end)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>(); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 随机初始化数组</span></span><br><span class="line">  random_device rd;</span><br><span class="line">  <span class="function">mt19937 <span class="title">gen</span><span class="params">(rd())</span></span>;</span><br><span class="line"></span><br><span class="line">  <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">arr</span><span class="params">(ARRAY_SIZE)</span></span>;</span><br><span class="line">  <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; ARRAY_SIZE; i++) &#123;</span><br><span class="line">    arr[i] = <span class="built_in">gen</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 调用多线程快排</span></span><br><span class="line">  <span class="built_in">parallelQuickSort</span>(arr, <span class="number">0</span>, arr.<span class="built_in">size</span>());</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="20-说说什么是信号量，有什么作用？"><a href="#20-说说什么是信号量，有什么作用？" class="headerlink" title="20.说说什么是信号量，有什么作用？"></a>20.说说什么是信号量，有什么作用？</h2><p>由于信号量只能进行两种操作等待和发送信号，即P(sv)和V(sv)，</p>
<p>(1）P(sv)操作：如果sv的值大于零，就给它减1；如果它的值为零，就挂起该进程的执行（信号量的值为正，进程获得该资源的使用权，进程将信号量减1，表示它使用了一个资源单位）。</p>
<p>（2）V(sv)操作：如果有其他进程因等待sv而被挂起，就让它恢复运行，如果没有进程因等待sv而挂起，就给它加1（若此时信号量的值为0，则进程进入挂起状态，直到信号量的值大于0，若进程被唤醒则返回至第一步）。</p>
<p>作用：用于多进程对共享数据对象的读取，它主要是用来保护共享资源（信号量也属于临界资源），使得资源在一个时刻只有一个进程独享。</p>
<ul>
<li><strong>代码示例</strong></li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;semaphore&gt;</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;thread&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function">std::semaphore <span class="title">sem</span><span class="params">(<span class="number">1</span>)</span></span>; <span class="comment">// 初始化信号量为1</span></span><br><span class="line"><span class="type">int</span> count = <span class="number">0</span>; <span class="comment">// 共享的计数变量</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="comment">// 获取信号量,实现互斥</span></span><br><span class="line">    sem.<span class="built_in">acquire</span>(); </span><br><span class="line">    count++; <span class="comment">// 访问共享变量</span></span><br><span class="line">    sem.<span class="built_in">release</span>(); <span class="comment">// 释放信号量</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span>(<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">if</span>(count == <span class="number">60</span>) &#123;  </span><br><span class="line">       <span class="comment">// 获取信号量,实现互斥</span></span><br><span class="line">       sem.<span class="built_in">acquire</span>();  </span><br><span class="line">       <span class="comment">// count已累加到60,重置为0</span></span><br><span class="line">       count = <span class="number">0</span>;</span><br><span class="line">       sem.<span class="built_in">release</span>(); <span class="comment">// 释放信号量</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function">std::thread <span class="title">t1</span><span class="params">(inc)</span></span>;</span><br><span class="line">  <span class="function">std::thread <span class="title">t2</span><span class="params">(reset)</span></span>;</span><br><span class="line"></span><br><span class="line">  t1.<span class="built_in">join</span>();</span><br><span class="line">  t2.<span class="built_in">join</span>();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><strong>分析</strong>:</p>
<ul>
<li><p>inc线程使用信号量sem实现对count的互斥访问</p>
</li>
<li><p>当count累加到60时,reset线程获取信号量,同步访问count变量并置0</p>
</li>
<li><p>两个线程通过获取&#x2F;释放信号量实现了对共享变量的互斥与同步</p>
</li>
<li><p>信号量sem起到了线程间的控制作用</p>
</li>
</ul>
<p>以上代码通过注释和分析展示了信号量的互斥与同步作用。信号量是多线程编程一个非常重要的同步机制。</p>
<h2 id="21-进程、线程的中断切换的过程是怎样的？"><a href="#21-进程、线程的中断切换的过程是怎样的？" class="headerlink" title="21.进程、线程的中断切换的过程是怎样的？"></a>21.进程、线程的中断切换的过程是怎样的？</h2><p>上下文切换指的是内核（操作系统的核心）在CPU上对进程或者线程进行切换</p>
<p>进程上下文切换</p>
<p>（1）保护被中断进程的处理器现场信息</p>
<p>（2）修改被中断进程的进程控制块有关信息，如进程状态等</p>
<p>（3）把被中断进程的进程控制块加入有关队列</p>
<p>（4）选择下一个占有处理器运行的进程</p>
<p>（5）根据被选中进程设置操作系统用到的地址转换和存储保护信息</p>
<p>（6）根据被选中进程恢复处理器现场</p>
<h2 id="22-多线程和单线程有什么区别，多线程编程要注意什么，多线程加锁需要注意什么？"><a href="#22-多线程和单线程有什么区别，多线程编程要注意什么，多线程加锁需要注意什么？" class="headerlink" title="22.多线程和单线程有什么区别，多线程编程要注意什么，多线程加锁需要注意什么？"></a>22.多线程和单线程有什么区别，多线程编程要注意什么，多线程加锁需要注意什么？</h2><p> 多线程和单线程编程主要有以下区别:</p>
<ol>
<li><p>单线程程序只有一个执行序列,多线程程序有多个执行流同时执行。</p>
</li>
<li><p>多线程可以有效利用多核CPU,提高程序执行效率。单线程无法利用多核特性。</p>
</li>
<li><p>多线程需要处理线程同步和竞争条件,编程复杂度更高。</p>
</li>
<li><p>多线程程序cpu、内存开销更大,调试更困难。</p>
</li>
</ol>
<p>多线程编程需要注意:</p>
<ol>
<li><p>共享资源访问需要加锁同步,防止竞争。</p>
</li>
<li><p>线程安全,避免数据竞争和死锁。</p>
</li>
<li><p>合理设计任务分工,避免过多线程调度开销。</p>
</li>
<li><p>注意线程间同步和通信,消息传递等。</p>
</li>
</ol>
<p>多线程加锁需要注意:</p>
<ol>
<li><p>锁的粒度,不要锁定过多资源。</p>
</li>
<li><p>尽量减少临界区代码,缩小锁定范围。</p>
</li>
<li><p>避免死锁,加锁顺序要一致。</p>
</li>
<li><p>使用读写锁,分离读写操作。</p>
</li>
<li><p>利用线程间同步原语如信号量、条件变量。</p>
</li>
<li><p>避免重复加锁和遗漏解锁。</p>
</li>
</ol>
<p>综上,多线程编程可以利用多核CPU,但也面临更多问题。需要注意设计方式,正确使用同步原语,才能发挥其优势。</p>
<h2 id="23-为什么要创建线程池？线程池的设计思路，线程池中线程的数量由什么确定？"><a href="#23-为什么要创建线程池？线程池的设计思路，线程池中线程的数量由什么确定？" class="headerlink" title="23.为什么要创建线程池？线程池的设计思路，线程池中线程的数量由什么确定？"></a>23.<strong>为什么要创建线程池？</strong>线程池的设计思路，线程池中线程的数量由什么确定？</h2><p>原因：</p>
<p>创建和销毁线程的花销是比较大的，这些时间可能比处理业务时间还要长，这样频繁的创建和销毁线程，再加上业务工作的线程，消耗系统资源的时间，可能导致系统资源不足，线程池可以提升系统效率</p>
<p>实现线程池步骤：</p>
<p>\1.  设置一个生产者消费队列，作为临时资源</p>
<p>\2.  初始化n个线程，并让其运行起来，加锁去队列里去任务运行</p>
<p>\3.  当任务队列为空时，所有线程阻塞</p>
<p>\4.  当生产者队列来了一个任务后，先对队列加锁，把任务挂到队列上，然后使用条件变量通知阻塞中的线程来处理</p>
<ul>
<li><p><strong>C++实现</strong></p>
<ul>
<li><p>创建任务队列</p>
<ul>
<li><p>类的申明</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 定义任务结构体</span></span><br><span class="line"><span class="keyword">using</span> callback = <span class="built_in">void</span>(*)(<span class="type">void</span>*);</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">Task</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        function = <span class="literal">nullptr</span>;</span><br><span class="line">        arg = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Task</span>(callback f, <span class="type">void</span>* arg)</span><br><span class="line">    &#123;</span><br><span class="line">        function = f;</span><br><span class="line">        <span class="keyword">this</span>-&gt;arg = arg;</span><br><span class="line">    &#125;</span><br><span class="line">    callback function;</span><br><span class="line">    <span class="type">void</span>* arg;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 任务队列</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskQueue</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskQueue</span>();</span><br><span class="line">    ~<span class="built_in">TaskQueue</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 添加任务</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(Task&amp; task)</span></span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">addTask</span><span class="params">(callback func, <span class="type">void</span>* arg)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 取出一个任务</span></span><br><span class="line">    <span class="function">Task <span class="title">takeTask</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前队列中任务个数</span></span><br><span class="line">    <span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">taskNumber</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> m_queue.<span class="built_in">size</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">pthread_mutex_t</span> m_mutex;    <span class="comment">// 互斥锁</span></span><br><span class="line">    std::queue&lt;Task&gt; m_queue;   <span class="comment">// 任务队列</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者: 苏丙榅</span><br><span class="line">链接: https:<span class="comment">//subingwen.cn/linux/threadpool-cpp/</span></span><br><span class="line">来源: 爱编程的大丙</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<ul>
<li><p>类的定义</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">TaskQueue::TaskQueue()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_init(&amp;m_mutex, NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">TaskQueue::~TaskQueue()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_destroy(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TaskQueue::addTask(Task&amp; task)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;m_mutex);</span><br><span class="line">    m_queue.push(task);</span><br><span class="line">    pthread_mutex_unlock(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void TaskQueue::addTask(callback func, void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    pthread_mutex_lock(&amp;m_mutex);</span><br><span class="line">    Task task;</span><br><span class="line">    task.function = func;</span><br><span class="line">    task.arg = arg;</span><br><span class="line">    m_queue.push(task);</span><br><span class="line">    pthread_mutex_unlock(&amp;m_mutex);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Task TaskQueue::takeTask()</span><br><span class="line">&#123;</span><br><span class="line">    Task t;</span><br><span class="line">    pthread_mutex_lock(&amp;m_mutex);</span><br><span class="line">    if (m_queue.size() &gt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        t = m_queue.front();</span><br><span class="line">        m_queue.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_mutex_unlock(&amp;m_mutex);</span><br><span class="line">    return t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者: 苏丙榅</span><br><span class="line">链接: https://subingwen.cn/linux/threadpool-cpp/</span><br><span class="line">来源: 爱编程的大丙</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
</li>
<li><p>线程池</p>
<ul>
<li>类声明</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class ThreadPool</span><br><span class="line">&#123;</span><br><span class="line">public:</span><br><span class="line">    ThreadPool(int min, int max);</span><br><span class="line">    ~ThreadPool();</span><br><span class="line"></span><br><span class="line">    // 添加任务</span><br><span class="line">    void addTask(Task task);</span><br><span class="line">    // 获取忙线程的个数</span><br><span class="line">    int getBusyNumber();</span><br><span class="line">    // 获取活着的线程个数</span><br><span class="line">    int getAliveNumber();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    // 工作的线程的任务函数</span><br><span class="line">    static void* worker(void* arg);</span><br><span class="line">    // 管理者线程的任务函数</span><br><span class="line">    static void* manager(void* arg);</span><br><span class="line">    void threadExit();</span><br><span class="line"></span><br><span class="line">private:</span><br><span class="line">    pthread_mutex_t m_lock;</span><br><span class="line">    pthread_cond_t m_notEmpty;</span><br><span class="line">    pthread_t* m_threadIDs;</span><br><span class="line">    pthread_t m_managerID;</span><br><span class="line">    TaskQueue* m_taskQ;</span><br><span class="line">    int m_minNum;</span><br><span class="line">    int m_maxNum;</span><br><span class="line">    int m_busyNum;</span><br><span class="line">    int m_aliveNum;</span><br><span class="line">    int m_exitNum;</span><br><span class="line">    bool m_shutdown = false;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者: 苏丙榅</span><br><span class="line">链接: https://subingwen.cn/linux/threadpool-cpp/</span><br><span class="line">来源: 爱编程的大丙</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure>

<ul>
<li>类定义</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br></pre></td><td class="code"><pre><span class="line">ThreadPool::ThreadPool(int minNum, int maxNum)</span><br><span class="line">&#123;</span><br><span class="line">    // 实例化任务队列</span><br><span class="line">    m_taskQ = new TaskQueue;</span><br><span class="line">    do &#123;</span><br><span class="line">        // 初始化线程池</span><br><span class="line">        m_minNum = minNum;</span><br><span class="line">        m_maxNum = maxNum;</span><br><span class="line">        m_busyNum = 0;</span><br><span class="line">        m_aliveNum = minNum;</span><br><span class="line"></span><br><span class="line">        // 根据线程的最大上限给线程数组分配内存</span><br><span class="line">        m_threadIDs = new pthread_t[maxNum];</span><br><span class="line">        if (m_threadIDs == nullptr)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;malloc thread_t[] 失败....&quot; &lt;&lt; endl;;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">        // 初始化</span><br><span class="line">        memset(m_threadIDs, 0, sizeof(pthread_t) * maxNum);</span><br><span class="line">        // 初始化互斥锁,条件变量</span><br><span class="line">        if (pthread_mutex_init(&amp;m_lock, NULL) != 0 ||</span><br><span class="line">            pthread_cond_init(&amp;m_notEmpty, NULL) != 0)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;init mutex or condition fail...&quot; &lt;&lt; endl;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        /////////////////// 创建线程 //////////////////</span><br><span class="line">        // 根据最小线程个数, 创建线程</span><br><span class="line">        for (int i = 0; i &lt; minNum; ++i)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_create(&amp;m_threadIDs[i], NULL, worker, this);</span><br><span class="line">            cout &lt;&lt; &quot;创建子线程, ID: &quot; &lt;&lt; to_string(m_threadIDs[i]) &lt;&lt; endl;</span><br><span class="line">        &#125;</span><br><span class="line">        // 创建管理者线程, 1个</span><br><span class="line">        pthread_create(&amp;m_managerID, NULL, manager, this);</span><br><span class="line">    &#125; while (0);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ThreadPool::~ThreadPool()</span><br><span class="line">&#123;</span><br><span class="line">    m_shutdown = 1;</span><br><span class="line">    // 销毁管理者线程</span><br><span class="line">    pthread_join(m_managerID, NULL);</span><br><span class="line">    // 唤醒所有消费者线程</span><br><span class="line">    for (int i = 0; i &lt; m_aliveNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        pthread_cond_signal(&amp;m_notEmpty);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (m_taskQ) delete m_taskQ;</span><br><span class="line">    if (m_threadIDs) delete[]m_threadIDs;</span><br><span class="line">    pthread_mutex_destroy(&amp;m_lock);</span><br><span class="line">    pthread_cond_destroy(&amp;m_notEmpty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void ThreadPool::addTask(Task task)</span><br><span class="line">&#123;</span><br><span class="line">    if (m_shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    // 添加任务，不需要加锁，任务队列中有锁</span><br><span class="line">    m_taskQ-&gt;addTask(task);</span><br><span class="line">    // 唤醒工作的线程</span><br><span class="line">    pthread_cond_signal(&amp;m_notEmpty);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ThreadPool::getAliveNumber()</span><br><span class="line">&#123;</span><br><span class="line">    int threadNum = 0;</span><br><span class="line">    pthread_mutex_lock(&amp;m_lock);</span><br><span class="line">    threadNum = m_aliveNum;</span><br><span class="line">    pthread_mutex_unlock(&amp;m_lock);</span><br><span class="line">    return threadNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int ThreadPool::getBusyNumber()</span><br><span class="line">&#123;</span><br><span class="line">    int busyNum = 0;</span><br><span class="line">    pthread_mutex_lock(&amp;m_lock);</span><br><span class="line">    busyNum = m_busyNum;</span><br><span class="line">    pthread_mutex_unlock(&amp;m_lock);</span><br><span class="line">    return busyNum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 工作线程任务函数</span><br><span class="line">void* ThreadPool::worker(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool* pool = static_cast&lt;ThreadPool*&gt;(arg);</span><br><span class="line">    // 一直不停的工作</span><br><span class="line">    while (true)</span><br><span class="line">    &#123;</span><br><span class="line">        // 访问任务队列(共享资源)加锁</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;m_lock);</span><br><span class="line">        // 判断任务队列是否为空, 如果为空工作线程阻塞</span><br><span class="line">        while (pool-&gt;m_taskQ-&gt;taskNumber() == 0 &amp;&amp; !pool-&gt;m_shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;thread &quot; &lt;&lt; to_string(pthread_self()) &lt;&lt; &quot; waiting...&quot; &lt;&lt; endl;</span><br><span class="line">            // 阻塞线程</span><br><span class="line">            pthread_cond_wait(&amp;pool-&gt;m_notEmpty, &amp;pool-&gt;m_lock);</span><br><span class="line"></span><br><span class="line">            // 解除阻塞之后, 判断是否要销毁线程</span><br><span class="line">            if (pool-&gt;m_exitNum &gt; 0)</span><br><span class="line">            &#123;</span><br><span class="line">                pool-&gt;m_exitNum--;</span><br><span class="line">                if (pool-&gt;m_aliveNum &gt; pool-&gt;m_minNum)</span><br><span class="line">                &#123;</span><br><span class="line">                    pool-&gt;m_aliveNum--;</span><br><span class="line">                    pthread_mutex_unlock(&amp;pool-&gt;m_lock);</span><br><span class="line">                    pool-&gt;threadExit();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        // 判断线程池是否被关闭了</span><br><span class="line">        if (pool-&gt;m_shutdown)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;m_lock);</span><br><span class="line">            pool-&gt;threadExit();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 从任务队列中取出一个任务</span><br><span class="line">        Task task = pool-&gt;m_taskQ-&gt;takeTask();</span><br><span class="line">        // 工作的线程+1</span><br><span class="line">        pool-&gt;m_busyNum++;</span><br><span class="line">        // 线程池解锁</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;m_lock);</span><br><span class="line">        // 执行任务</span><br><span class="line">        cout &lt;&lt; &quot;thread &quot; &lt;&lt; to_string(pthread_self()) &lt;&lt; &quot; start working...&quot; &lt;&lt; endl;</span><br><span class="line">        task.function(task.arg);</span><br><span class="line">        delete task.arg;</span><br><span class="line">        task.arg = nullptr;</span><br><span class="line"></span><br><span class="line">        // 任务处理结束</span><br><span class="line">        cout &lt;&lt; &quot;thread &quot; &lt;&lt; to_string(pthread_self()) &lt;&lt; &quot; end working...&quot;;</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;m_lock);</span><br><span class="line">        pool-&gt;m_busyNum--;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;m_lock);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">// 管理者线程任务函数</span><br><span class="line">void* ThreadPool::manager(void* arg)</span><br><span class="line">&#123;</span><br><span class="line">    ThreadPool* pool = static_cast&lt;ThreadPool*&gt;(arg);</span><br><span class="line">    // 如果线程池没有关闭, 就一直检测</span><br><span class="line">    while (!pool-&gt;m_shutdown)</span><br><span class="line">    &#123;</span><br><span class="line">        // 每隔5s检测一次</span><br><span class="line">        sleep(5);</span><br><span class="line">        // 取出线程池中的任务数和线程数量</span><br><span class="line">        //  取出工作的线程池数量</span><br><span class="line">        pthread_mutex_lock(&amp;pool-&gt;m_lock);</span><br><span class="line">        int queueSize = pool-&gt;m_taskQ-&gt;taskNumber();</span><br><span class="line">        int liveNum = pool-&gt;m_aliveNum;</span><br><span class="line">        int busyNum = pool-&gt;m_busyNum;</span><br><span class="line">        pthread_mutex_unlock(&amp;pool-&gt;m_lock);</span><br><span class="line"></span><br><span class="line">        // 创建线程</span><br><span class="line">        const int NUMBER = 2;</span><br><span class="line">        // 当前任务个数&gt;存活的线程数 &amp;&amp; 存活的线程数&lt;最大线程个数</span><br><span class="line">        if (queueSize &gt; liveNum &amp;&amp; liveNum &lt; pool-&gt;m_maxNum)</span><br><span class="line">        &#123;</span><br><span class="line">            // 线程池加锁</span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;m_lock);</span><br><span class="line">            int num = 0;</span><br><span class="line">            for (int i = 0; i &lt; pool-&gt;m_maxNum &amp;&amp; num &lt; NUMBER</span><br><span class="line">                &amp;&amp; pool-&gt;m_aliveNum &lt; pool-&gt;m_maxNum; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                if (pool-&gt;m_threadIDs[i] == 0)</span><br><span class="line">                &#123;</span><br><span class="line">                    pthread_create(&amp;pool-&gt;m_threadIDs[i], NULL, worker, pool);</span><br><span class="line">                    num++;</span><br><span class="line">                    pool-&gt;m_aliveNum++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;m_lock);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        // 销毁多余的线程</span><br><span class="line">        // 忙线程*2 &lt; 存活的线程数目 &amp;&amp; 存活的线程数 &gt; 最小线程数量</span><br><span class="line">        if (busyNum * 2 &lt; liveNum &amp;&amp; liveNum &gt; pool-&gt;m_minNum)</span><br><span class="line">        &#123;</span><br><span class="line">            pthread_mutex_lock(&amp;pool-&gt;m_lock);</span><br><span class="line">            pool-&gt;m_exitNum = NUMBER;</span><br><span class="line">            pthread_mutex_unlock(&amp;pool-&gt;m_lock);</span><br><span class="line">            for (int i = 0; i &lt; NUMBER; ++i)</span><br><span class="line">            &#123;</span><br><span class="line">                pthread_cond_signal(&amp;pool-&gt;m_notEmpty);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    return nullptr;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 线程退出</span><br><span class="line">void ThreadPool::threadExit()</span><br><span class="line">&#123;</span><br><span class="line">    pthread_t tid = pthread_self();</span><br><span class="line">    for (int i = 0; i &lt; m_maxNum; ++i)</span><br><span class="line">    &#123;</span><br><span class="line">        if (m_threadIDs[i] == tid)</span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; &quot;threadExit() function: thread &quot; </span><br><span class="line">                &lt;&lt; to_string(pthread_self()) &lt;&lt; &quot; exiting...&quot; &lt;&lt; endl;</span><br><span class="line">            m_threadIDs[i] = 0;</span><br><span class="line">            break;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    pthread_exit(NULL);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">作者: 苏丙榅</span><br><span class="line">链接: https://subingwen.cn/linux/threadpool-cpp/</span><br><span class="line">来源: 爱编程的大丙</span><br><span class="line">著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p>线程的数量：</p>
<p>CPU、IO&#x2F;并发、并行有关</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果是CPU密集型应用，则线程池大小设置为：CPU数目+1</span><br><span class="line">如果是IO密集型应用，则线程池大小设置为：2*CPU数目+1</span><br><span class="line">最佳线程数目 = （线程等待时间与线程CPU时间之比 + 1）* CPU数目</span><br></pre></td></tr></table></figure>

<p>所以线程等待时间所占比例越高，需要越多线程。线程CPU时间所占比例越高，需要越少线程</p>
<h2 id="24-说说多路IO复用技术有哪些，区别是什么？"><a href="#24-说说多路IO复用技术有哪些，区别是什么？" class="headerlink" title="24.说说多路IO复用技术有哪些，区别是什么？"></a>24.说说多路IO复用技术有哪些，区别是什么？</h2><p>常见的IO多路转接方式有：<strong>select、poll、epoll</strong>。</p>
<p>1）每次调用select，都需要把fd集合从用户态拷贝到内核态，这个开销在fd很多时会很大；而epoll保证了每个fd在整个过程中只会拷贝一次</p>
<p>2）每次调用select都需要在内核遍历传递进来的所有fd，才知道哪些fd是被设置了；而epoll只需要轮询一次fd集合，同时查看就绪链表中有没有就绪的fd就可以了</p>
<p>Select设置监听的集合不能被重新使用</p>
<p>3）select支持的文件描述符数量太小了，默认是1024；而epoll没有这个限制，它所支持的 fd上限是最大可以打开文件的数目，这个数字一般远大于2048</p>
<p><strong>epoll</strong>为什么高效：拷贝、查询、返回</p>
<p>1）select，poll实现需要自己不断轮询所有fd集合，直到设备就绪，期间可能要睡眠和唤醒多次交替。而epoll只要判断一下就绪链表是否为空就行了，这节省了大量的CPU时间</p>
<p>2）select，poll每次调用都要把fd集合从用户态往内核态拷贝一次，并且要把当前进程往设备等待队列中挂一次，而epoll只要一次拷贝，而且把当前进程往等待队列上挂也只挂一次，这也能节省不少的开销。</p>
<p>3）当我们调用 epoll_wait() 函数返回的不是实际的描述符，而是一个代表就绪描述符数 </p>
<p>量的值，这个时候需要去 epoll 指定的一个数组中(epoll_event定义的结构体)依次取得相应数量的 socket 描述符即可，这个数组里面保存的都是可以的文件描述符，而不需要遍历扫描所有的 socket 描述符，因此这里的时间复杂度是 O(1)，</p>
<p>这里和select的区别是select返回的也是可用的数量，但是并没有告诉你可用的文件描述符是谁，你必须得遍历全部的文件描述符，才知道是那些就绪了</p>
<p>epoll 最大的优点就在于它只管就绪的 socket 描述符，而跟 socket 描述符的总数无关</p>
<p>调用epoll_creat创建一个epoll实例，就会在内核中创建 用来存放监听文件描述符的红黑树，另一个是就绪表</p>
<h2 id="25-说说多路IO复用技术有哪些，区别是什么？"><a href="#25-说说多路IO复用技术有哪些，区别是什么？" class="headerlink" title="25.说说多路IO复用技术有哪些，区别是什么？"></a>25.说说多路IO复用技术有哪些，区别是什么？</h2><p><strong>select，poll，epoll</strong>都是IO多路复用的机制，I&#x2F;O多路复用就是通过一种机制，可以监视多个文件描述符，一旦某个文件描述符就绪（一般是读就绪或者写就绪），能够通知应用程序进行相应的读写操作</p>
<ul>
<li>epoll的工作模式为LT和ET即水平触发和边缘触发，默认是水平触发</li>
</ul>
<p>区别：</p>
<p>水平触发：一但文件描述符就绪后就会一直通知你去读取数据，直到你把数据读完</p>
<p>边沿触发：一会通知你一次有数据可读，所以你必须得把数据读完，不然会在再通知你数据可读，下次再来数据的时候才会再通知你，必须配合无阻塞即read&#x2F;rec为非阻塞读数据数据，如果使用阻塞就到导致重新阻塞，无法继续监听其他文件描述符</p>
<p>epoll函数使用：灵魂三步曲</p>
<p>epoll使用原理：</p>
<p><strong>1、首先使用epoll_create(监听的最大数量)，</strong></p>
<p><strong>2、把需要监听的文件描述符添加到epoll里面去  epoll_ctl(epfd,EPOLL_CTL_ADD,sockfd,&amp;ev);</strong></p>
<p>  需要设置监听那个文件描述符，什么类型，比如监听的是可写还是可读，使用struct epoll_event结构体设置</p>
<p>  参数说明：</p>
<p>  其中EPOLL_CTL_ADD表示添加，相反的还有删除EPOLL_CTL_DEL</p>
<p>  ev是个 struct epoll_event结构体，这个结构体可以用来设置需要监听的文件描述符</p>
<p>  struct epoll_event</p>
<p>  {</p>
<p>  uint32_t events;   &#x2F;* Epoll events *&#x2F;</p>
<p>  epoll_data_t data;  &#x2F;* User data variable </p>
<p>  };</p>
<p>  其中events可以设置为</p>
<p>  enum EPOLL_EVENTS</p>
<p> {</p>
<p>  EPOLLIN &#x3D; 0x001,&#x2F;&#x2F;表示被监听的文件为可读时发生</p>
<p>#define EPOLLIN EPOLLIN</p>
<p>  EPOLLPRI &#x3D; 0x002,</p>
<p>#define EPOLLPRI EPOLLPRI</p>
<p>  EPOLLOUT &#x3D; 0x004,</p>
<p>#define EPOLLOUT EPOLLOUT  &#x2F;&#x2F;可写时发生</p>
<p>  EPOLLRDNORM &#x3D; 0x040,</p>
<p><strong>3.等待监听的文件描述符发生epoll_wait(epfd,events,Maxsize,-1);</strong></p>
<p>  events是epoll_event结构体用来已经保存可读或可写的文件描述符，用户只需通过判断该结构体中的data.fd即可知道是否为需要的文件描述符</p>
<p>  -1 表示阻塞等待</p>
<p>使用例子:使用epoll监听服务器的客户端</p>
<p>\1)  创建套接字</p>
<p>\2)  绑定IP，端口</p>
<p>\3)  监听</p>
<p>\4)  Epoll_create创建epoll的文件描述符或者说句柄</p>
<p>\5)  epoll_ctl()设置监听的文件描述符，。这里主要是创建的套接字</p>
<p>\6)  Epoll_wait()等待文件描述符可用，返回值为可用的文件描述符数量</p>
<p>\7)  判断可用的文件描述符是否为创建的套接字，如果是则表示有新客户连接，服务器需要接收连接，并把通信的fd设置到监听里面去</p>
<p>\8)  如果判断不是创建的套接字，则表示是客户端的fd，那么此时需要去处理客户端的信息，比如读取客户端发上来的数据，或者发数据给客户端，又或者创建线程处理复杂任务</p>
<p>代码如下：</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  int sockfd,confd[1024]=&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  struct sockaddr_in serveraddr_in,clientaddr_in;</span><br><span class="line"></span><br><span class="line">//1.创建套接字</span><br><span class="line"></span><br><span class="line">  sockfd=socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line"></span><br><span class="line">  if(sockfd==-1)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    perror(&quot;socket&quot;);</span><br><span class="line"></span><br><span class="line">​    exit(1);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//2.绑定</span><br><span class="line"></span><br><span class="line">  memset(&amp;serveraddr_in,0,sizeof(serveraddr_in));</span><br><span class="line"></span><br><span class="line">  serveraddr_in.sin_family=AF_INET;</span><br><span class="line"></span><br><span class="line">  serveraddr_in.sin_port=htons(6868);</span><br><span class="line"></span><br><span class="line">  serveraddr_in.sin_addr.s_addr=inet_addr(&quot;172.18.125.34&quot;);</span><br><span class="line"></span><br><span class="line">  int ret=bind(sockfd,(struct sockaddr *)&amp;serveraddr_in,sizeof(serveraddr_in));</span><br><span class="line"></span><br><span class="line">  if(ret==-1)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    perror(&quot;bind&quot;);</span><br><span class="line"></span><br><span class="line">​    exit(1);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//3.监听</span><br><span class="line"></span><br><span class="line">  ret=listen(sockfd,10);</span><br><span class="line"></span><br><span class="line">  if(ret==-1)</span><br><span class="line"></span><br><span class="line">  &#123;  </span><br><span class="line"></span><br><span class="line">​    perror(&quot;listen&quot;);</span><br><span class="line"></span><br><span class="line">​    exit(1);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  int length=sizeof(clientaddr_in);</span><br><span class="line"></span><br><span class="line">  char buf[128]=&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  int Maxsize=128;</span><br><span class="line"></span><br><span class="line">  struct epoll_event ev,events[Maxsize];//ev用来写进监听，events[]用来保存监听到的</span><br><span class="line"></span><br><span class="line">  ev.events=EPOLLIN;//监听可读</span><br><span class="line"></span><br><span class="line">  ev.data.fd=sockfd;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  int epfd=epoll_create(Maxsize);//1.创建epoll对象</span><br><span class="line"></span><br><span class="line">  if(-1==epfd)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    perror(&quot;epfd&quot;);</span><br><span class="line"></span><br><span class="line">​    exit(1);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  ret=epoll_ctl(epfd,EPOLL_CTL_ADD,sockfd,&amp;ev);//2.给epoll添加fd到集合,</span><br><span class="line"></span><br><span class="line">  if(ret==-1)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    perror(&quot;epoll_ctl&quot;);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  while(1)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    int i;</span><br><span class="line"></span><br><span class="line">​    int num=epoll_wait(epfd,events,Maxsize,-1);//3. -1表示阻塞等待epoll可读，监听的保存到events，返回值为可读fd个数</span><br><span class="line"></span><br><span class="line">​    if(-1==num)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      perror(&quot;epoll_wait&quot;);</span><br><span class="line"></span><br><span class="line">​      exit(1);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    for(i=0;i&lt;num;i++)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      int fd;</span><br><span class="line"></span><br><span class="line">​      if(events[i].data.fd==sockfd)//4.判断是否为sockfd,是表示有新客户端连接,处理：接受连接，保存通信fd到监听集合</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        fd=accept(sockfd,(struct sockaddr* )&amp;clientaddr_in,&amp;length);</span><br><span class="line"></span><br><span class="line">​        printf(&quot;客户端%s连接成功 fd=%d\n&quot;,inet_ntoa(clientaddr_in.sin_addr),fd); </span><br><span class="line"></span><br><span class="line">​        </span><br><span class="line"></span><br><span class="line">​        ev.events=EPOLLIN;</span><br><span class="line"></span><br><span class="line">​        ev.data.fd=fd;</span><br><span class="line"></span><br><span class="line">​        ret=epoll_ctl(epfd,EPOLL_CTL_ADD,fd,&amp;ev);//5.给epoll添加客户端fd-------&gt;通信的fd,</span><br><span class="line"></span><br><span class="line">​        if(ret==-1)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          perror(&quot;epoll_ctl&quot;);</span><br><span class="line"></span><br><span class="line">​          exit(1);</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​      </span><br><span class="line"></span><br><span class="line">​      else//表示是客户端的通信fd可用</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        if(events[i].events &amp; EPOLLIN)//判断是否为可读</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          ret=recv(events[i].data.fd,buf,sizeof(buf),0);//</span><br><span class="line"></span><br><span class="line">​          if(ret==-1)</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">​            perror(&quot;recv&quot;);</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​          if(ret==0)</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">​             perror(&quot;退出&quot;);</span><br><span class="line"></span><br><span class="line">​             ev.data.fd=events[i].data.fd;</span><br><span class="line"></span><br><span class="line">​             ev.events=EPOLLIN;</span><br><span class="line"></span><br><span class="line">​             epoll_ctl(epfd,EPOLL_CTL_DEL,ev.data.fd,&amp;ev);//删除掉线的文件描述符</span><br><span class="line"></span><br><span class="line">​             close(ev.data.fd);</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​          else</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">​            printf(&quot;收到来自%d的信息:%s\n&quot;,events[i].data.fd,buf);</span><br><span class="line"></span><br><span class="line">​             memset(buf,0,sizeof(buf));</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​        &#125; </span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>





<p>Select函数的使用：</p>
<p>函数原型：</p>
<p> int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);</p>
<p>-参数：</p>
<p>   -nfds:表示最大的文件描述符号+1,之所以加1因为内核遍历哪些文件描述符可用时是从0开始，比如最大文件描述符为4，那么就需要遍历4+1次才能遍历到文件描述符4</p>
<p>-readfds：文件描述符可读的集合，当调用select函数之后，比如监听的可读文件描述符总共有4个，但只有文件描述符3可读时，该函数会把readfds里的其他文件描述符置0,所以要想每次都监听全部的文件描述符就需要事先保存下来</p>
<p>-timeout：设置阻塞监听时间，为null时阻塞，为0时不阻塞</p>
<p>注意;不需要监听的集合只需要设置为null即可</p>
<p>​    void FD_CLR(int fd, fd_set *set);&#x2F;&#x2F;清除监听集合中的fd文件描述符，清除之后不再监听</p>
<p>​    int FD_ISSET(int fd, fd_set *set);&#x2F;&#x2F;判断监听集合中，fd文件描述符是否可用</p>
<p>​    void FD_SET(int fd, fd_set *set);&#x2F;&#x2F;设置文件描述符fd到监听集合中监听</p>
<p>​    void FD_ZERO(fd_set *set);&#x2F;&#x2F;清除所有的文件描述符</p>
<p>该函数只能监听1024个文件描述符，因为sizeof(fd_set)&#x3D;128个字节，128*8&#x3D;1024位，每一位表示一个文件描述符</p>
<p>工作流程：</p>
<p>1.用户设置需要监听的文件描述符到监听的集合</p>
<p>void FD_SET(int fd, fd_set *set);&#x2F;&#x2F;设置文件描述符fd到监听集合中监听</p>
<p>2.调用select函数监听文件描述符集合</p>
<p>int select(int nfds, fd_set *readfds, fd_set *writefds,fd_set *exceptfds, struct timeval *timeout);</p>
<p>此时用会把需要监听的集合拷贝到内核</p>
<p>3.监听到集合中文件描述符可用时，把监听的集合从内核拷贝到用户(内核自己完成)</p>
<p>4.判断集合中是否有自己想要的文件描述符</p>
<p>int FD_ISSET(int fd, fd_set *set);&#x2F;&#x2F;判断监听集合中，fd文件描述符是否可用</p>
 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br></pre></td><td class="code"><pre><span class="line">int main()</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">  int sockfd,confd[1024]=&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  struct sockaddr_in serveraddr_in,clientaddr_in;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">  //1.创建套接字</span><br><span class="line"></span><br><span class="line">  sockfd=socket(AF_INET,SOCK_STREAM,0);</span><br><span class="line"></span><br><span class="line">  if(sockfd==-1)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">​    perror(&quot;socket&quot;);</span><br><span class="line"></span><br><span class="line">​    exit(1);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//2.绑定</span><br><span class="line"></span><br><span class="line">  memset(&amp;serveraddr_in,0,sizeof(serveraddr_in));</span><br><span class="line"></span><br><span class="line">  serveraddr_in.sin_family=AF_INET;</span><br><span class="line"></span><br><span class="line">  serveraddr_in.sin_port=htons(6868);</span><br><span class="line"></span><br><span class="line">  serveraddr_in.sin_addr.s_addr=inet_addr(&quot;172.18.125.34&quot;);</span><br><span class="line"></span><br><span class="line">  int ret=bind(sockfd,(struct sockaddr *)&amp;serveraddr_in,sizeof(serveraddr_in));</span><br><span class="line"></span><br><span class="line">  if(ret==-1)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    perror(&quot;bind&quot;);</span><br><span class="line"></span><br><span class="line">    exit(1);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">//3.监听</span><br><span class="line"></span><br><span class="line">  ret=listen(sockfd,10);</span><br><span class="line"></span><br><span class="line">  if(ret==-1)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    perror(&quot;listen&quot;);</span><br><span class="line"></span><br><span class="line">    exit(1);</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  int length=sizeof(clientaddr_in);</span><br><span class="line"></span><br><span class="line">  fd_set readfd,tmpfd;   //监听集合</span><br><span class="line"></span><br><span class="line">  FD_ZERO(&amp;readfd);    //清空集合</span><br><span class="line"></span><br><span class="line">  FD_SET(sockfd,&amp;readfd); //设置集合</span><br><span class="line"></span><br><span class="line">  int maxfd=sockfd; //设置监听个数</span><br><span class="line"></span><br><span class="line">  char buf[128]=&#123;0&#125;;</span><br><span class="line"></span><br><span class="line">  while(1)</span><br><span class="line"></span><br><span class="line">  &#123;</span><br><span class="line"></span><br><span class="line">    tmpfd=readfd;//保存集合，因为当有文件有可读或写异常时，会把其他文件描述符删掉，留下可用的文件描述符</span><br><span class="line"></span><br><span class="line">​    int ret=select(maxfd+1,&amp;tmpfd,NULL,NULL,NULL);//监听有可读文件描述符</span><br><span class="line"></span><br><span class="line">​    if(ret==-1)</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      perror(&quot;select&quot;);</span><br><span class="line"></span><br><span class="line">​      exit(1);</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line"> </span><br><span class="line"></span><br><span class="line">​    if(FD_ISSET(sockfd,&amp;tmpfd))//判断是否为sockfd,是，表示新客户端连接</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      int i;</span><br><span class="line"></span><br><span class="line">​      for( i=0;i&lt;1024;i++)//判断哪个通信fd是没用过的，因为当客户端退出后，那个位置就为0</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        if(confd[i]==0)</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          break;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​     //4.接受链接</span><br><span class="line"></span><br><span class="line">​      confd[i]=accept(sockfd,(struct sockaddr*)&amp;clientaddr_in,(socklen_t *)&amp;length);</span><br><span class="line"></span><br><span class="line">​      if(confd[i]==-1)</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        perror(&quot;accept&quot;);</span><br><span class="line"></span><br><span class="line">​        exit(1);</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    //打印连接的客户端IP</span><br><span class="line"></span><br><span class="line">​      printf(&quot;客户端%s连接成功 fd=%d\n&quot;,inet_ntoa(clientaddr_in.sin_addr),confd[i]);</span><br><span class="line"></span><br><span class="line">​      FD_SET(confd[i],&amp;readfd);//把上线的客户端的文件描述符写入集合</span><br><span class="line"></span><br><span class="line">​      if(confd[i]&gt;maxfd)//修改监听的最大个数</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        maxfd=confd[i];</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">​    else//表示是通信描述符的</span><br><span class="line"></span><br><span class="line">​    &#123;</span><br><span class="line"></span><br><span class="line">​      memset(buf,0,sizeof(buf));//清除Buf</span><br><span class="line"></span><br><span class="line">​      for(int i=0;i&lt;1024;i++)//判断是哪个通信文件描述符</span><br><span class="line"></span><br><span class="line">​      &#123;</span><br><span class="line"></span><br><span class="line">​        if(FD_ISSET(confd[i],&amp;tmpfd))</span><br><span class="line"></span><br><span class="line">​        &#123;</span><br><span class="line"></span><br><span class="line">​          int ret=recv(confd[i],buf,sizeof(buf),0);//接收来自客户端信息</span><br><span class="line"></span><br><span class="line">​          if(ret==-1)</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">​            perror(&quot;recv&quot;);</span><br><span class="line"></span><br><span class="line">​            </span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​          if(ret==0)//判断是否为退出</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">​            perror(&quot;客户端退出&quot;);</span><br><span class="line"></span><br><span class="line">​            close(confd[i]);//关闭通信文件描述符</span><br><span class="line"></span><br><span class="line">​            FD_CLR(confd[i],&amp;readfd);//从监听集合中清除通信文件符</span><br><span class="line"></span><br><span class="line">​            confd[i]=0;//文件描述符置0</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​          else</span><br><span class="line"></span><br><span class="line">​          &#123;</span><br><span class="line"></span><br><span class="line">​            printf(&quot;收到客户%d的信息:%s\n&quot;,confd[i],buf);//打印信息</span><br><span class="line"></span><br><span class="line">​          &#125;</span><br><span class="line"></span><br><span class="line">​          break;</span><br><span class="line"></span><br><span class="line">​        &#125;</span><br><span class="line"></span><br><span class="line">​      &#125;</span><br><span class="line"></span><br><span class="line">​    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">  return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="26-有名管道-named-pipe-的通信步骤："><a href="#26-有名管道-named-pipe-的通信步骤：" class="headerlink" title="26.有名管道(named pipe)的通信步骤："></a>26.有名管道(named pipe)的通信步骤：</h2><p>有名管道(named pipe)是一种进程间通信机制,可以实现不同进程之间的数据传递。</p>
<p>有名管道的使用步骤:</p>
<ol>
<li>创建管道,指定管道名称</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkfifo</span>(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">mode_t</span> mode);</span><br></pre></td></tr></table></figure>

<p>这将创建一个指定名字的有名管道。</p>
<ol start="2">
<li>打开管道</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(pathname, O_RDONLY); <span class="comment">// 打开读端</span></span><br><span class="line"><span class="type">int</span> fd = <span class="built_in">open</span>(pathname, O_WRONLY); <span class="comment">// 打开写端</span></span><br></pre></td></tr></table></figure>

<p>通过open以只读或只写方式打开管道的两端。</p>
<ol start="3">
<li>写入管道</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">write</span>(fd, buf, count); <span class="comment">// 写入数据</span></span><br></pre></td></tr></table></figure>

<p>一个进程可以通过write写入管道。</p>
<ol start="4">
<li>从管道读取</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">read</span>(fd, buf, count); <span class="comment">// 从管道读取数据</span></span><br></pre></td></tr></table></figure>

<p>另一个进程可以通过read读取数据。</p>
<ol start="5">
<li>关闭管道</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">close</span>(fd);</span><br></pre></td></tr></table></figure>

<p>数据传输完成后,关闭管道的文件描述符。</p>
<p>通过这种机制,两个没有亲缘关系的进程可以通过有名管道进行通信。</p>
<h2 id="27-信号的常见知识"><a href="#27-信号的常见知识" class="headerlink" title="27.信号的常见知识"></a>27.信号的常见知识</h2><h3 id="1-信号的作用：用于通知接收进程有某种事件发生，除了用于进程间通信，还可以发送信号给自己"><a href="#1-信号的作用：用于通知接收进程有某种事件发生，除了用于进程间通信，还可以发送信号给自己" class="headerlink" title="1)信号的作用：用于通知接收进程有某种事件发生，除了用于进程间通信，还可以发送信号给自己"></a>1)信号的作用：用于通知接收进程有某种事件发生，除了用于进程间通信，还可以发送信号给自己</h3><h3 id="2-常见信号："><a href="#2-常见信号：" class="headerlink" title="2)常见信号："></a>2)常见信号：</h3><p>常见的Linux信号及功能如下:</p>
<ul>
<li><p><strong>SIGKILL</strong> - 终止进程的信号,用于无条件结束进程,进程无法拦截或忽略这个信号。</p>
</li>
<li><p><strong>SIGSTOP</strong> - 暂停进程的信号,可以使进程停止运行。</p>
</li>
<li><p><strong>SIGCONT</strong> - 继续运行进程的信号,可以使被SIGSTOP暂停的进程继续运行。</p>
</li>
<li><p><strong>SIGALRM</strong> - 计时器报警信号,可以用于进程定时发送报警。通过alarm()和setitimer()可以设置定时器,定时到期后会给进程发送SIGALRM信号。</p>
</li>
<li><p><strong>SIGINT</strong> - 中断进程的信号,通常通过Ctrl+C发送,可以允许进程进行清理工作后终止。</p>
</li>
<li><p><strong>SIGTERM</strong> - 优雅终止进程的信号,通知进程正常退出。</p>
</li>
<li><p><strong>SIGUSR1</strong>&#x2F;<strong>SIGUSR2</strong> - 用户自定义信号,可以用于进程间通信。</p>
</li>
<li><p><strong>SIGSEGV</strong> - 无效内存访问信号,通常是程序访问了非法内存地址。</p>
</li>
<li><p><strong>SIGPIPE</strong> - 管道破裂信号,写端进程退出但读端仍在读取管道时发送。</p>
</li>
<li><p><strong>SIGHUP</strong> - 挂起进程信号,通常在终端会话结束时发送给相关进程。</p>
</li>
</ul>
<p>这些是在Linux编程中常用的信号,可以用来终止、停止、恢复进程,也可以用于进程间通信。需要根据具体场景选择合适的信号。</p>
<h3 id="3-发送信号："><a href="#3-发送信号：" class="headerlink" title="3)发送信号："></a>3)发送信号：</h3><p>1.int kill(pid_t pid, int sig)</p>
<p>参数说明：</p>
<p>  如果pid为正，则将信号sig发送到pid指定ID的进程</p>
<p>  如果pid等于0，则sig被发送到调用进程的进程组中的每个进程</p>
<p>  如果pid等于-1，则sig被发送到调用进程有权发送信号的每个进程，进程除外（初始）</p>
<p>返回值：成功0，失败-1</p>
<p>发送信号给进程或线程</p>
<p>2.int raise(int sig)  (只能发送给自己)</p>
<p>对于进程该函数相当于： kill(getpid(), sig);</p>
<p>对于线程该函数相当于：pthread_kill(pthread_self(), sig);</p>
<h3 id="4-进程可以对信号的操作："><a href="#4-进程可以对信号的操作：" class="headerlink" title="4)进程可以对信号的操作："></a>4)进程可以对信号的操作：</h3><p>​      ┊  1.缺省方式</p>
<p>​      ┊  2.忽略信号</p>
<p>​      ┊  3.捕捉信号</p>
<p>​      </p>
<p>void ( *signal(int signum, void (*handler)(int)) ) (int);</p>
<p>signum:要设置的信号类型</p>
<p>handler :指定的信号处理函数：</p>
<p>SIG_DFL代表缺省处理—–&gt;系统默认处理方式，比如终止终端</p>
<p>SIG_IGN代表忽略信号</p>
<p>捕捉信号 —-》自己定义的处理方法 </p>
<p>​                     </p>
<p>(新版本）sighandler_t signal(int signum, sighandler_t handler);</p>
<p>signum:要设置的信号类型</p>
<p>handler :指定的信号处理函数：</p>
<p>SIG_DFL代表缺省处理</p>
<p>SIG_IGN代表忽略信号</p>
<p>捕捉信号—》自己定义的处理方法 </p>
<p>注意： The signals SIGKILL and SIGSTOP cannot be caught or ignored.</p>
<p>不能捕捉或忽略信号SIGKILL和SIGSTOP</p>
<h3 id="5-创建定时器："><a href="#5-创建定时器：" class="headerlink" title="5)创建定时器："></a>5)创建定时器：</h3><p>  常用于检测网络超时</p>
<p>   unsigned int alarm(unsigned int seconds);</p>
<p>  参数说明:seconds为秒，如果seconds为0则取消定时器</p>
<p>  返回值：成功返回上个定时器的剩余时间，失败返回EOF</p>
<p>   注意一个进程只能创建一个定时器，时间到就产生SIGALRM信号</p>
<p>通过这个函数我们可以设计一个定时器，时间到之后进程就会产生一个SIGALRM信号，接收进程只需调用void ( *signal(int signum, void (*handler)(int)) ) (int);函数收信号即可</p>
<p>比如：</p>
<p>void signal_funtion(int signal)</p>
<p>{</p>
<p>  if(signal&#x3D;&#x3D;SIGALRM)</p>
<p>  {</p>
<p>​    printf(“alarm\n”);</p>
<p>  }</p>
<p>}</p>
<p>int main()</p>
<p>{</p>
<p>  int ret;</p>
<p>  ret&#x3D;alarm(3);&#x2F;&#x2F;1.设置闹钟信号</p>
<p>  printf(“%d\n”,ret);</p>
<p>  signal(SIGALRM,signal_funtion);&#x2F;&#x2F;2.改变SIGALRM信号默认处理方式</p>
<p>  ret&#x3D;pause();&#x2F;&#x2F;3.进入睡眠（防止闹钟时间过长，还没到时间程序就运行完），直到中断信号出现，才有可能继续往下</p>
<p>  printf(“pause %d\n”,ret);</p>
<p>return 0;</p>
<p>}</p>
<h2 id="28-共享内存"><a href="#28-共享内存" class="headerlink" title="28.共享内存"></a>28.共享内存</h2><p>线程A</p>
<p>1）创建共享内存</p>
<p>2）映射到进程地址</p>
<p>3）通过映射地址操作共享内存</p>
<p>4）关闭映射</p>
<p>线程B</p>
<p>1）打开共享内存</p>
<p>2）映射</p>
<p>3）操作共享内存</p>
<p>4）关闭映射</p>
<h2 id="29-说说软链接和硬链接的区别"><a href="#29-说说软链接和硬链接的区别" class="headerlink" title="29.   说说软链接和硬链接的区别"></a>29.   说说软链接和硬链接的区别</h2><p> 软链接(Symbolic Link)和硬链接(Hard Link)都是Linux文件系统中的链接文件,主要区别如下:</p>
<p>1、软链接是文件的引用,它只记录了原始文件路径,不占用额外空间。硬链接是文件的拷贝,它指向原始文件inode,占用相同大小空间。</p>
<p>2、删除原文件,软链接失效,硬链接仍可用。</p>
<p>3、软链接可以跨文件系统,硬链接不能跨文件系统。</p>
<p>4、软链接可以对目录创建链接。硬链接只可对文件创建链接。</p>
<p>5、软链接使用绝对路径或相对路径,硬链接只使用绝对路径。</p>
<p>6、软链接由ln -s 创建,硬链接由ln 创建。</p>
<p>总结一下:</p>
<p>软链接类似Windows的快捷方式,硬链接是文件副本,同时指向源文件。软链接更灵活,硬链接保证文件不会失效。</p>
<p>硬链接在修改原文件时更安全,软链接修改原文件路径就会失效。</p>
<p>使用ln -s指令进行软连接</p>
<h2 id="30-说说静态库和动态库怎么制作及如何使用，区别是什么"><a href="#30-说说静态库和动态库怎么制作及如何使用，区别是什么" class="headerlink" title="30.说说静态库和动态库怎么制作及如何使用，区别是什么"></a>30.说说静态库和动态库怎么制作及如何使用，区别是什么</h2><h3 id="静态库的制作："><a href="#静态库的制作：" class="headerlink" title="静态库的制作："></a>静态库的制作：</h3><p>1）编译成可执行的.o文件</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -c main.c -o main.o</span><br></pre></td></tr></table></figure>

<p>2）将可执行文件制作成库</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ar rcs libxxx.a file1.o file2.o</span><br></pre></td></tr></table></figure>

<p>静态库的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -lxxx -o test</span><br></pre></td></tr></table></figure>

<h3 id="动态库的制作"><a href="#动态库的制作" class="headerlink" title="动态库的制作"></a>动态库的制作</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc -shared -o libxxx.so file1.o file2.o</span><br></pre></td></tr></table></figure>

<p>动态库的使用：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gcc test.c -lxxx -o test</span><br></pre></td></tr></table></figure>

<h3 id="区别-什么时候加载，加载速度如何，内存占用大小，执行效率"><a href="#区别-什么时候加载，加载速度如何，内存占用大小，执行效率" class="headerlink" title="区别;什么时候加载，加载速度如何，内存占用大小，执行效率"></a>区别;什么时候加载，加载速度如何，内存占用大小，执行效率</h3><p>1)静态库代码装载的速度快，执行速度略比动态库快。</p>
<p>2)动态库更加节省内存，可执行文件体积比静态库小很多。</p>
<p>3)静态库是在编译时加载，动态库是在运行时加载。</p>
<p>4)生成的静态链接库，Windows下以.lib为后缀，Linux下以.a为后缀。生成的动态链接库，Windows下以.dll为后缀，Linux下以.so为后缀</p>
<h2 id="31-简述GDB常见的调试命令，什么是条件断点，多进程下如何调试"><a href="#31-简述GDB常见的调试命令，什么是条件断点，多进程下如何调试" class="headerlink" title="31.简述GDB常见的调试命令，什么是条件断点，多进程下如何调试"></a>31.简述GDB常见的调试命令，什么是条件断点，多进程下如何调试</h2><p>1）在编译的时候必须加上参数-g</p>
<p>Gcc main.c -g -o ma in</p>
<p>2)多进程下如何调试：用set follow-fork-mode child 调试子进程</p>
<p>​     或者set follow-fork-mode parent 调试父进程</p>
<p>3)条件断点：break if 条件 以条件表达式设置断点</p>
<h2 id="32-简述Linux系统态与用户态，什么时候会进入系统态？"><a href="#32-简述Linux系统态与用户态，什么时候会进入系统态？" class="headerlink" title="32.简述Linux系统态与用户态，什么时候会进入系统态？"></a>32.简述Linux系统态与用户态，什么时候会进入系统态？</h2><p><strong>用户态</strong>:进程执行自己的代码时处于用户态。大部分指令都能正常执行。但是不能执行特权指令,访问受保护的内存空间。</p>
<p><strong>系统态</strong>:进程执行内核代码时处于系统态。可以执行任何特权指令,访问系统资源。</p>
<p>什么时候进入内核态：<strong>a.系统调用(主动) b.异常 c.设备中断</strong></p>
<p>为什么区分用户态和内核态：<strong>在cpu中有些指令比较危险，如果用错就会导致系统崩溃，比如清内存</strong></p>
<h2 id="33-什么是页表，为什么要有？"><a href="#33-什么是页表，为什么要有？" class="headerlink" title="33.    什么是页表，为什么要有？"></a>33.    什么是页表，为什么要有？</h2><p>&#x3D;&#x3D;页表&#x3D;&#x3D;是虚拟内存的概念 ，虚拟内存映到物理内存的映射表，就是页表</p>
<p> <img src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/image-20230818163015649.png" alt="image-20230818163015649"></p>
<p>原因：虚拟内存要和物理地址映射起来，就必须要通过映射表找到物理地址，如果将每一个虚拟内存的 Byte 都对应到物理内存的地址，每个条目最少需要 8字节（32位虚拟地址-&gt;32位物理地址），在 4G 内存的情况下，就需要 32GB 的空间来存放对照表，那么这张表就大得真正的物理地址也放不下了，于是操作系统引入了页（Page）的概念，使用4个字节的映射就对应物理内存的1页—&gt;4k内存，这样把全部虚拟地址映射到页表就会节省很大空间</p>
<p>一般来说进程的虚拟地址要想找到物理地址就必须通过MMU，MMU里面放的就是映射表，通过虚拟内存的高20位知道自己在映射表的位置，也就是对应的物理地址的页起始位置，虚拟地址的低12位对应物理地址的页里面的具体地址</p>
<p>比如：0x00003 005中前20位对应映射表的0x80003000,那么就会去找物理地址0x8000 3000为起始的页，005表示在页中的第几个，这样就可以找到具体物理地址</p>
<p>由于映射表是4个字节就映射物理地址的1页即4k,那么映射完整个物理地址之后就会节省大量空间，不同进程之间的页表是不一样的</p>
<h2 id="34-简述操作系统中malloc的实现原理"><a href="#34-简述操作系统中malloc的实现原理" class="headerlink" title="34.   简述操作系统中malloc的实现原理"></a>34.   简述操作系统中malloc的实现原理</h2><p>malloc底层实现：</p>
<p>当开辟的空间小于 128K 时，调用 brk（）函数；</p>
<p>当开辟的空间大于 128K 时，调用mmap（）。</p>
<p>malloc采用的是内存池的管理方式，以减少内存碎片。先申请大块内存作为堆区，然后将堆区分为多个内存块。当用户申请内存时，直接从堆区分配一块合适的空闲快。采用隐式链表将所有空闲块，每一个空闲块记录了一个未分配的、连续的内存地址</p>
<h2 id="35-简述操作系统中的缺页中断。"><a href="#35-简述操作系统中的缺页中断。" class="headerlink" title="35.    简述操作系统中的缺页中断。"></a>35.    简述操作系统中的缺页中断。</h2><p>malloc和mmap函数在内存分配时只是建立了进程的虚拟地址，并没有分配虚拟地址对应的物理内存，当进程访问这些没有建立映射关系的虚拟内存时，处理器自动触发一个缺页异常，引发缺页中断</p>
<p>缺页异常后将产生一个缺页中断，此时操作系统会根据页表中的外存地址在外存中找到所缺的一页，将其调入内存</p>
<h2 id="36-简述mmap的原理和使用场景"><a href="#36-简述mmap的原理和使用场景" class="headerlink" title="36.   简述mmap的原理和使用场景"></a>36.   简述mmap的原理和使用场景</h2><p><strong>原理</strong>：<strong>mmap****是一种内存映射文件的方法</strong>，即将一个文件或者其它对象映射到进程的地址空间，实现文件磁盘地址和进程虚拟地址空间中一段虚拟地址的一一对映关系。实现这样的映射关系后，进程就可以采用指针的方式读写操作这一段内存，而系统会自动回写脏页面到对应的文件磁盘上，即完成了对文件的操作而不必再调用read, write等系统调用函数。相反，内核空间对这段区域的修改也直接反映用户空间，从而可以实现不同进程间的文件共享</p>
<h2 id="37-为什么使用虚拟内存"><a href="#37-为什么使用虚拟内存" class="headerlink" title="37.为什么使用虚拟内存"></a>37.为什么使用虚拟内存</h2><p>（1）扩大地址空间。每个进程独占一个4G空间，虽然真实物理内存没那么多。</p>
<p>（2）内存保护：防止不同进程对物理内存的争夺和践踏，可以对特定内存地址提供写保护，防止恶意篡改。</p>
<p>（3）可以实现内存共享，方便进程通信。</p>
<p>（4）可以避免内存碎片，虽然物理内存可能不连续，但映射到虚拟内存上可以连续</p>
<h2 id="38-用户空间和内核空间的通信方式"><a href="#38-用户空间和内核空间的通信方式" class="headerlink" title="38.用户空间和内核空间的通信方式"></a>38.用户空间和内核空间的通信方式</h2><p>1.使用内核提供的API函数</p>
<p>Copy_from_user copy_to_user</p>
<p>2.proc文件系统</p>
<p>3.mmap系统调用</p>
<h2 id="38-中断的响应执行流程？听说过顶半部和底半部吗？"><a href="#38-中断的响应执行流程？听说过顶半部和底半部吗？" class="headerlink" title="38.中断的响应执行流程？听说过顶半部和底半部吗？"></a>38.中断的响应执行流程？听说过顶半部和底半部吗？</h2><p>cpu接收中断—–&gt;保存中断上下文跳转到中断的处理函数—–&gt;执行中断上半部分—–&gt;执行中断的下半部分—–&gt;恢复中断的上下文</p>
<p>顶半部执行一般是比较紧急的任务，比如清中断，下半部执行的一些不太紧急的人任务可以节省中断处理时间</p>
<h2 id="39-busybox是什么？"><a href="#39-busybox是什么？" class="headerlink" title="39.   busybox是什么？"></a>39.   busybox是什么？</h2><p>缩小版的uinx系统常用命令工具箱</p>
<h2 id="40-什么是根文件系统"><a href="#40-什么是根文件系统" class="headerlink" title="40.   什么是根文件系统"></a>40.   什么是根文件系统</h2><p>是内核启动时所挂载的第一个文件系统，内核代码映像文件保存在根文件系统中</p>
<h2 id="41-自旋锁是什么？信号量是什么？二者有什么区别？"><a href="#41-自旋锁是什么？信号量是什么？二者有什么区别？" class="headerlink" title="41.   自旋锁是什么？信号量是什么？二者有什么区别？"></a>41.   自旋锁是什么？信号量是什么？二者有什么区别？</h2><p>自旋锁：—-&gt;不会进入睡眠</p>
<p>自旋锁只有两个状态锁定和解锁，在锁定期间其他进程我是不能进行访问资源，比如B想访问只能在外面等到解锁之后才能访问，如果B等待的时间过长那么就要考虑使用互斥锁</p>
<p>信号量：——&gt;会进入睡眠</p>
<p>信号量是个计数器，用来统计资源的可用次数，比如B进程想使用资源，当资源可用的是时候就会去通知B，而不是让B在哪里等着，不会一直占用CPU，这样就可以提高系统的执行效率</p>
<p>区别：</p>
<p>信号量会让等待信号的的进程进入睡眠，所以信号量适用于锁会被长时间持有的情况</p>
<p>自旋锁会一直在哪里循环判断所是否可用占用极高CPU所以不适用长时间持有所的情况</p>
<p>自旋锁禁止处理器抢占，信号量允许，这也就是为什么自旋锁不能睡眠的原因，如果自旋锁睡眠，那么就无法通过抢占唤醒睡眠的自旋锁</p>
<p>信号量不能用于中断中，因为信号量会引起休眠，中断不能睡眠，自旋锁可以</p>
<h2 id="42-为什么堆的空间不是连续的？"><a href="#42-为什么堆的空间不是连续的？" class="headerlink" title="42.   为什么堆的空间不是连续的？"></a>42.   为什么堆的空间不是连续的？</h2><p>堆内存的管理只要是靠链表来维护已用和空闲的内存，当我们申请堆内存空间时会在空间里面找到一个满足要求的内存，当我们释放掉大的内存空间时，这些大块空间就会和那些零散的空间合并成一个空间快</p>
<h2 id="43-Linux内核的组成部分（进程、内存管理、文件系统、网络接口）"><a href="#43-Linux内核的组成部分（进程、内存管理、文件系统、网络接口）" class="headerlink" title="43.Linux内核的组成部分（进程、内存管理、文件系统、网络接口）"></a>43.Linux内核的组成部分（进程、内存管理、文件系统、网络接口）</h2><h2 id="44-Linux系统的组成部分（内核、shell、文件系统、应用程序）"><a href="#44-Linux系统的组成部分（内核、shell、文件系统、应用程序）" class="headerlink" title="44.Linux系统的组成部分（内核、shell、文件系统、应用程序）"></a>44.Linux系统的组成部分（内核、shell、文件系统、应用程序）</h2><h2 id="45-线程的同步和互斥的区别和联系"><a href="#45-线程的同步和互斥的区别和联系" class="headerlink" title="45.线程的同步和互斥的区别和联系"></a>45.线程的同步和互斥的区别和联系</h2><p>同步是指按照一定顺序执行，同步里面包含了互斥，互斥是指一个资源只能出现一个进程进行访问，但是互斥没办法按照顺序执行，是无序的</p>
<h2 id="46-常见命令"><a href="#46-常见命令" class="headerlink" title="46.常见命令"></a>46.常见命令</h2><h3 id="1-解压、压缩命令"><a href="#1-解压、压缩命令" class="headerlink" title="1.解压、压缩命令"></a>1.解压、压缩命令</h3><p>tar是操作.tar的命令</p>
<p>Zip 后缀.zip  </p>
<p>unzip</p>
<p>​     gzip是压缩.gz压缩包的命令</p>
<p>​     compress：压缩.Z文件</p>
<p>​     uncompress：解压缩.Z文件</p>
<h3 id="2-查看内存"><a href="#2-查看内存" class="headerlink" title="2.查看内存"></a>2.查看内存</h3><p>Free </p>
<p>Cat &#x2F;proc&#x2F;meminfo</p>
<p>Df -h</p>
<p>top</p>
<h3 id="3-查看cpu"><a href="#3-查看cpu" class="headerlink" title="3.查看cpu"></a>3.查看cpu</h3><p>Cat &#x2F;proc&#x2F;cpuinfo</p>
<h3 id="4-ps-grep-xxx"><a href="#4-ps-grep-xxx" class="headerlink" title="4.ps grep|xxx"></a>4.ps grep|xxx</h3><h3 id="5-修改文件权限"><a href="#5-修改文件权限" class="headerlink" title="5.修改文件权限"></a>5.修改文件权限</h3><p>Chmod u+rwx g+rwx o+rwx</p>
<h3 id="6-查看内核"><a href="#6-查看内核" class="headerlink" title="6.查看内核"></a>6.查看内核</h3><p> Uname -a</p>
<h3 id="7-查看栈大小"><a href="#7-查看栈大小" class="headerlink" title="7.查看栈大小"></a>7.查看栈大小</h3><p> ulimit -s</p>
<h2 id="47-进程终止"><a href="#47-进程终止" class="headerlink" title="47.进程终止"></a>47.进程终止</h2><p>进程终止分为正常和异常</p>
<h2 id="48-特殊进程"><a href="#48-特殊进程" class="headerlink" title="48.特殊进程"></a>48.特殊进程</h2><p>Linux下有3个特殊的进程，</p>
<p>idle进程(PID &#x3D; 0), idle进程是由系统自动创建，运行在内核态</p>
<p>init进程(PID &#x3D; 1)，init进程是由idle创建运行在用户空间，其父进程就是idle</p>
<p>kthreadd(PID &#x3D; 2)。内核线程，负责内核线程的创建工作，其父进程就是idle</p>
<h2 id="48-多线程中使用较多的函数"><a href="#48-多线程中使用较多的函数" class="headerlink" title="48.   多线程中使用较多的函数"></a>48.   多线程中使用较多的函数</h2><p>1.获得父进程ID</p>
<p>pthread_t pthread_self(void);</p>
<p>2.互斥量初始化</p>
<p>int pthread_mutex_init(pthread_mutex_t *restrict mutex,const pthread_mutexattr_t *restrict attr);</p>
<h2 id="50-pthread-cond-signal-和-pthread-cond-broadcast"><a href="#50-pthread-cond-signal-和-pthread-cond-broadcast" class="headerlink" title="50.pthread_cond_signal()和 pthread_cond_broadcast()"></a>50.pthread_cond_signal()和 pthread_cond_broadcast()</h2><p>如果调用 pthread_cond_signal()和 pthread_cond_broadcast()向指定条件变量发送信号时，若无任何线程等待该条件变量， 这个信号也就会不了了之</p>
<h2 id="51-驱动里面为什么需要并发和互斥"><a href="#51-驱动里面为什么需要并发和互斥" class="headerlink" title="51.驱动里面为什么需要并发和互斥"></a>51.驱动里面为什么需要并发和互斥</h2><p>并发是指多个单元同时执行，这样就会是共享内存的数据被修改，形成一种竞争，所以我们需要互斥让一个时间段只能一个单元对数据访问，像自旋锁，信号量都是可用的操作</p>
<h2 id="52-软中断和硬中断的区别"><a href="#52-软中断和硬中断的区别" class="headerlink" title="52.   软中断和硬中断的区别"></a>52.   软中断和硬中断的区别</h2><h2 id="52-fork和vfork的区别"><a href="#52-fork和vfork的区别" class="headerlink" title="52.   fork和vfork的区别"></a>52.   fork和vfork的区别</h2><p>Vfork中子进程修改全局变量会影响父进程的全局变量</p>
<p>注意第二点</p>
<h2 id="53-什么是虚拟内存"><a href="#53-什么是虚拟内存" class="headerlink" title="53.什么是虚拟内存"></a>53.什么是虚拟内存</h2><p>虚拟内存是一种内存管理技术，之所以有这个虚拟内存，主要是为了扩张内存，因为我们的这个代码数据什么都是存在硬盘中的，而CPU是没办法直接去拿硬盘的数据，必须借助内存，但是这个内存是有限的，所以但内存不够的时候就会把一部分这个硬盘作为虚拟内存，这样cpu就可以读取虚拟内存的数据</p>
<h2 id="54-并发编程的三个概念"><a href="#54-并发编程的三个概念" class="headerlink" title="54.并发编程的三个概念"></a>54.并发编程的三个概念</h2><p>在并发编程中，我们通常会遇到以下三个问题：</p>
<p>原子性问题，可见性问题，有序性问题</p>
<p><strong>原子性</strong>：即一个操作或者多个操作 要么全部执行并且执行的过程不会被任何因素打断，要么就都不执行</p>
<p><strong>可见性：</strong>是指当多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看得到修改的值</p>
<p><strong>有序性</strong>：即程序执行的顺序按照代码的先后顺序执行</p>
<h2 id="55-同步和异步"><a href="#55-同步和异步" class="headerlink" title="55.   同步和异步"></a>55.   同步和异步</h2><p>同步一般是指阻塞等待，异步一般是不需要等待，比如你发送数据到服务器，那么就不需要等待，直接去干别的事，一般来说异步的效率高于同步</p>
</article><div class="post-copyright"><div class="copyright-cc-box"><i class="anzhiyufont anzhiyu-icon-copyright"></i></div><div class="post-copyright__author_box"><a class="post-copyright__author_img" href="/" title="头像"><img class="post-copyright__author_img_back" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"><img class="post-copyright__author_img_front" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" title="头像" alt="头像"></a><div class="post-copyright__author_name">宁康</div><div class="post-copyright__author_desc">志存高远，脚踏实地</div></div><div class="post-copyright__post__info"><a class="post-copyright__original" title="该文章为原创文章，注意版权协议" href="http://example.com/2023/08/06/2023-08-6-%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/">原创</a><a class="post-copyright-title"><span onclick="rm.copyPageUrl('http://example.com/2023/08/06/2023-08-6-%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/')">面试八股文——操作系统</span></a></div><div class="post-tools" id="post-tools"><div class="post-tools-left"><div class="rewardLeftButton"><div class="post-reward" onclick="anzhiyu.addRewardMask()"><div class="reward-button button--animated" title="赞赏作者"><i class="anzhiyufont anzhiyu-icon-hand-heart-fill"></i>打赏作者</div><div class="reward-main"><div class="reward-all"><span class="reward-title">感谢你赐予我前进的力量</span><ul class="reward-group"><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-weichat.png" alt="微信"/></a><div class="post-qr-code-desc">微信</div></li><li class="reward-item"><a href="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" target="_blank"><img class="post-qr-code-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/qrcode-alipay.png" alt="支付宝"/></a><div class="post-qr-code-desc">支付宝</div></li></ul><a class="reward-main-btn" href="/about/#about-reward" target="_blank"><div class="reward-text">赞赏者名单</div><div class="reward-dec">因为你们的支持让我意识到写文章的价值🙏</div></a></div></div></div><div id="quit-box" onclick="anzhiyu.removeRewardMask()" style="display: none"></div></div><div class="shareRight"><div class="share-link mobile"><div class="share-qrcode"><div class="share-button" title="使用手机访问这篇文章"><i class="anzhiyufont anzhiyu-icon-qrcode"></i></div><div class="share-main"><div class="share-main-all"><div id="qrcode" title="http://example.com/2023/08/06/2023-08-6-%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"></div><div class="reward-dec">使用手机访问这篇文章</div></div></div></div></div><div class="share-link weibo"><a class="share-button" target="_blank" href="https://service.weibo.com/share/share.php?title=undefined&amp;url=http://example.com/2023/08/06/2023-08-6-%E9%9D%A2%E8%AF%95%E5%85%AB%E8%82%A1%E6%96%87%E2%80%94%E2%80%94%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/&amp;pic=undefined" rel="external nofollow noreferrer noopener"><i class="anzhiyufont anzhiyu-icon-weibo"></i></a></div><script>function copyCurrentPageUrl() {
  var currentPageUrl = window.location.href;
  var input = document.createElement("input");
  input.setAttribute("value", currentPageUrl);
  document.body.appendChild(input);
  input.select();
  input.setSelectionRange(0, 99999);
  document.execCommand("copy");
  document.body.removeChild(input);
}</script><div class="share-link copyurl"><div class="share-button" id="post-share-url" title="复制链接" onclick="copyCurrentPageUrl()"><i class="anzhiyufont anzhiyu-icon-link"></i></div></div></div></div></div><div class="post-copyright__notice"><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://example.com" target="_blank">宁康同学</a>！</span></div></div><div class="post-tools-right"><div class="tag_share"><div class="post-meta__box"><div class="post-meta__box__tag-list"><a class="post-meta__box__tags" href="/tags/C/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>C++<span class="tagsPageCount">7</span></a><a class="post-meta__box__tags" href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>操作系统<span class="tagsPageCount">4</span></a><a class="post-meta__box__tags" href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>多线程<span class="tagsPageCount">4</span></a><a class="post-meta__box__tags" href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/"><span class="tags-punctuation"> <i class="anzhiyufont anzhiyu-icon-tag"></i></span>内存管理<span class="tagsPageCount">1</span></a></div></div></div><div class="post_share"><div class="social-share" data-image="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"/><script src="https://cdn.cbd.int/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer="defer"></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/2023/07/07/2023-07-7-leetcode%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8/"><img class="prev-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">leetcode刷题笔记——链表</div></div></a></div><div class="next-post pull-right"><a href="/2023/08/06/2023-08-6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5(%E8%AF%BB%E5%86%99%E9%94%81)/"><img class="next-cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">操作系统——线程同步(读写锁)</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="anzhiyufont anzhiyu-icon-thumbs-up fa-fw" style="font-size: 1.5rem; margin-right: 4px"></i><span>喜欢这篇文章的人也看了</span></div><div class="relatedPosts-list"><div><a href="/2023/08/06/2023-08-6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5(%E4%BA%92%E6%96%A5%E9%87%8F)/" title="操作系统——线程同步(互斥量)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-08-06</div><div class="title">操作系统——线程同步(互斥量)</div></div></a></div><div><a href="/2023/08/06/2023-08-6-%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E2%80%94%E2%80%94%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5(%E8%AF%BB%E5%86%99%E9%94%81)/" title="操作系统——线程同步(读写锁)"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-08-06</div><div class="title">操作系统——线程同步(读写锁)</div></div></a></div><div><a href="/2023/08/06/2023-08-6-C++%E5%88%B7%E9%A2%98%E7%AC%94%E8%AE%B0%E2%80%94%E2%80%94Linux%E7%BD%91%E7%BB%9C/" title="C++刷题笔记"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/fasle" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-08-06</div><div class="title">C++刷题笔记</div></div></a></div><div><a href="/2023/08/16/2023-08-16-%E5%A0%86%E5%92%8C%E6%A0%88%E7%9A%84%E5%8C%BA%E5%88%AB/" title="堆和栈的区别"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2023-08-16</div><div class="title">堆和栈的区别</div></div></a></div><div><a href="/2024/04/09/2023-08-9-C++%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="C++正则表达式"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-04-09</div><div class="title">C++正则表达式</div></div></a></div><div><a href="/2024/04/09/2023-08-9-%E8%A1%8C%E4%BA%91%E6%99%BA%E8%83%BD-%E7%AC%94%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88/" title="行云智能-笔试测试答卷"><img class="cover" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/" alt="cover"><div class="content is-center"><div class="date"><i class="anzhiyufont anzhiyu-icon-calendar-days fa-fw"></i> 2024-04-09</div><div class="title">行云智能-笔试测试答卷</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="card-content"><div class="author-info-avatar"><img class="avatar-img" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://bu.dusays.com/2023/04/27/64496e511b09c.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__description"></div><div class="author-info__bottom-group"><a class="author-info__bottom-group-left" href="/"><h1 class="author-info__name">宁康</h1><div class="author-info__desc">志存高远，脚踏实地</div></a><div class="card-info-social-icons is-center"><a class="social-icon faa-parent animated-hover" href="https://github.com/anzhiyu-c" target="_blank" title="Github"><i class="anzhiyufont anzhiyu-icon-github"></i></a><a class="social-icon faa-parent animated-hover" href="https://space.bilibili.com/372204786" target="_blank" title="BiliBili"><i class="anzhiyufont anzhiyu-icon-bilibili"></i></a></div></div></div></div><div class="card-widget anzhiyu-right-widget" id="card-wechat" onclick="null"><div id="flip-wrapper"><div id="flip-content"><div class="face" style="background: url(https://bu.dusays.com/2023/01/13/63c02edf44033.png) center center / 100% no-repeat"></div><div class="back face" style="background: url(https://bu.dusays.com/2023/05/13/645fa415e8694.png) center center / 100% no-repeat"></div></div></div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-bars"></i><span>文章目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#1%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E8%BF%9B%E7%A8%8B%EF%BC%9F%E4%BB%80%E4%B9%88%E6%98%AF%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">1.</span> <span class="toc-text">1、什么是进程？什么是线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E3%80%81%E5%8D%8F%E7%A8%8B%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">2.</span> <span class="toc-text">2.进程、线程、协程的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E8%BF%9B%E7%A8%8B%EF%BC%9F%E4%BD%95%E6%97%B6%E4%BD%BF%E7%94%A8%E5%A4%9A%E7%BA%BF%E7%A8%8B%EF%BC%9F-%E8%80%83%E8%99%91%E4%BC%98%E7%BC%BA%E7%82%B9"><span class="toc-number">3.</span> <span class="toc-text">3.何时使用多进程？何时使用多线程？(考虑优缺点)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-%E5%88%9B%E5%BB%BA%E8%BF%9B%E7%A8%8B%E7%9A%84%E6%96%B9%E5%BC%8F%EF%BC%9F"><span class="toc-number">4.</span> <span class="toc-text">4.创建进程的方式？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-%E8%BF%9B%E7%A8%8B%E6%9C%89%E5%87%A0%E7%A7%8D%E7%8A%B6%E6%80%81%EF%BC%9F"><span class="toc-number">5.</span> <span class="toc-text">5.进程有几种状态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E5%A4%A7%E5%9F%BA%E6%9C%AC%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">6.</span> <span class="toc-text">三大基本状态：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%A4%E7%A7%8D%E5%B8%B8%E8%A7%81%E7%8A%B6%E6%80%81%EF%BC%9A"><span class="toc-number">7.</span> <span class="toc-text">两种常见状态：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2%EF%BC%9A"><span class="toc-number">8.</span> <span class="toc-text">状态转换：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#6-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">9.</span> <span class="toc-text">6.进程间通信方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#7-%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E7%9A%84%E9%80%89%E6%8B%A9"><span class="toc-number">10.</span> <span class="toc-text">7.进程间通信的选择</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#8%E3%80%81%E4%BB%80%E4%B9%88%E6%98%AF%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E3%80%81%E5%AE%88%E6%8A%A4%E8%BF%9B%E7%A8%8B%EF%BC%9F"><span class="toc-number">11.</span> <span class="toc-text">8、什么是僵尸进程、孤儿进程、守护进程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#9-%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8D%B1%E5%AE%B3%EF%BC%9F"><span class="toc-number">12.</span> <span class="toc-text">9.僵尸进程有什么危害？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#10-%E7%BA%BF%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%E6%96%B9%E6%B3%95%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">13.</span> <span class="toc-text">10.线程间通信方法有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E8%AF%B4%E8%AF%B4%E7%BA%BF%E7%A8%8B%EF%BC%8C%E8%BF%9B%E7%A8%8B%E5%90%8C%E6%AD%A5%E6%96%B9%E5%BC%8F%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">14.</span> <span class="toc-text">11.说说线程，进程同步方式有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E4%BB%80%E4%B9%88%E6%98%AF%E5%86%85%E6%A0%B8%E7%BA%BF%E7%A8%8B%E5%92%8C%E7%94%A8%E6%88%B7%E7%BA%BF%E7%A8%8B%EF%BC%9F"><span class="toc-number">15.</span> <span class="toc-text">12.什么是内核线程和用户线程？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E7%AE%97%E6%B3%95%E5%8D%B3%E7%AD%96%E7%95%A5%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F"><span class="toc-number">16.</span> <span class="toc-text">12.   进程调度算法即策略有哪些？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#14-%E6%9C%89%E6%8A%A2%E5%8D%A0%E5%BC%8F%E5%92%8C%E9%9D%9E%E6%8A%A2%E5%8D%A0%E5%BC%8F%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">17.</span> <span class="toc-text">14.有抢占式和非抢占式的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#15-%E5%B9%B6%E5%8F%91%E5%92%8C%E5%B9%B6%E8%A1%8C"><span class="toc-number">18.</span> <span class="toc-text">15.并发和并行</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#16-%E8%BF%9B%E7%A8%8B%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E4%B8%AD%E7%9A%84%E7%AE%A1%E9%81%93%E9%80%9A%E4%BF%A1%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9A"><span class="toc-number">19.</span> <span class="toc-text">16.进程间的通信中的管道通信实现原理是什么：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#17-%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%AD%BB%E9%94%81%EF%BC%8C%E4%BA%A7%E7%94%9F%E7%9A%84%E6%9D%A1%E4%BB%B6%EF%BC%8C%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%EF%BC%9F"><span class="toc-number">20.</span> <span class="toc-text">17.说说什么死锁，产生的条件，如何解决？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#18-%E5%8D%95%E6%A0%B8%E6%9C%BA%E6%A2%B0%E4%B8%8A%E5%86%99%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%A8%8B%E5%BA%8F%EF%BC%8C%E6%98%AF%E5%90%A6%E8%80%83%E8%99%91%E5%8A%A0%E9%94%81%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">21.</span> <span class="toc-text">18.单核机械上写多线程程序，是否考虑加锁，为什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#19-%E4%BA%92%E6%96%A5%E9%94%81%E6%9C%BA%E5%88%B6%EF%BC%8C%E4%BA%92%E6%96%A5%E9%94%81%E5%92%8C%E8%AF%BB%E5%86%99%E9%94%81%E7%9A%84%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">22.</span> <span class="toc-text">19.互斥锁机制，互斥锁和读写锁的区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#20-%E8%AF%B4%E8%AF%B4%E4%BB%80%E4%B9%88%E6%98%AF%E4%BF%A1%E5%8F%B7%E9%87%8F%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F"><span class="toc-number">23.</span> <span class="toc-text">20.说说什么是信号量，有什么作用？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E8%BF%9B%E7%A8%8B%E3%80%81%E7%BA%BF%E7%A8%8B%E7%9A%84%E4%B8%AD%E6%96%AD%E5%88%87%E6%8D%A2%E7%9A%84%E8%BF%87%E7%A8%8B%E6%98%AF%E6%80%8E%E6%A0%B7%E7%9A%84%EF%BC%9F"><span class="toc-number">24.</span> <span class="toc-text">21.进程、线程的中断切换的过程是怎样的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%92%8C%E5%8D%95%E7%BA%BF%E7%A8%8B%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E7%BC%96%E7%A8%8B%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%8C%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%8A%A0%E9%94%81%E9%9C%80%E8%A6%81%E6%B3%A8%E6%84%8F%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">25.</span> <span class="toc-text">22.多线程和单线程有什么区别，多线程编程要注意什么，多线程加锁需要注意什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E5%88%9B%E5%BB%BA%E7%BA%BF%E7%A8%8B%E6%B1%A0%EF%BC%9F%E7%BA%BF%E7%A8%8B%E6%B1%A0%E7%9A%84%E8%AE%BE%E8%AE%A1%E6%80%9D%E8%B7%AF%EF%BC%8C%E7%BA%BF%E7%A8%8B%E6%B1%A0%E4%B8%AD%E7%BA%BF%E7%A8%8B%E7%9A%84%E6%95%B0%E9%87%8F%E7%94%B1%E4%BB%80%E4%B9%88%E7%A1%AE%E5%AE%9A%EF%BC%9F"><span class="toc-number">26.</span> <span class="toc-text">23.为什么要创建线程池？线程池的设计思路，线程池中线程的数量由什么确定？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#24-%E8%AF%B4%E8%AF%B4%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">27.</span> <span class="toc-text">24.说说多路IO复用技术有哪些，区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#25-%E8%AF%B4%E8%AF%B4%E5%A4%9A%E8%B7%AFIO%E5%A4%8D%E7%94%A8%E6%8A%80%E6%9C%AF%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">28.</span> <span class="toc-text">25.说说多路IO复用技术有哪些，区别是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#26-%E6%9C%89%E5%90%8D%E7%AE%A1%E9%81%93-named-pipe-%E7%9A%84%E9%80%9A%E4%BF%A1%E6%AD%A5%E9%AA%A4%EF%BC%9A"><span class="toc-number">29.</span> <span class="toc-text">26.有名管道(named pipe)的通信步骤：</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#27-%E4%BF%A1%E5%8F%B7%E7%9A%84%E5%B8%B8%E8%A7%81%E7%9F%A5%E8%AF%86"><span class="toc-number">30.</span> <span class="toc-text">27.信号的常见知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BF%A1%E5%8F%B7%E7%9A%84%E4%BD%9C%E7%94%A8%EF%BC%9A%E7%94%A8%E4%BA%8E%E9%80%9A%E7%9F%A5%E6%8E%A5%E6%94%B6%E8%BF%9B%E7%A8%8B%E6%9C%89%E6%9F%90%E7%A7%8D%E4%BA%8B%E4%BB%B6%E5%8F%91%E7%94%9F%EF%BC%8C%E9%99%A4%E4%BA%86%E7%94%A8%E4%BA%8E%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%8C%E8%BF%98%E5%8F%AF%E4%BB%A5%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%E7%BB%99%E8%87%AA%E5%B7%B1"><span class="toc-number">30.1.</span> <span class="toc-text">1)信号的作用：用于通知接收进程有某种事件发生，除了用于进程间通信，还可以发送信号给自己</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E5%B8%B8%E8%A7%81%E4%BF%A1%E5%8F%B7%EF%BC%9A"><span class="toc-number">30.2.</span> <span class="toc-text">2)常见信号：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E5%8F%91%E9%80%81%E4%BF%A1%E5%8F%B7%EF%BC%9A"><span class="toc-number">30.3.</span> <span class="toc-text">3)发送信号：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E8%BF%9B%E7%A8%8B%E5%8F%AF%E4%BB%A5%E5%AF%B9%E4%BF%A1%E5%8F%B7%E7%9A%84%E6%93%8D%E4%BD%9C%EF%BC%9A"><span class="toc-number">30.4.</span> <span class="toc-text">4)进程可以对信号的操作：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E5%88%9B%E5%BB%BA%E5%AE%9A%E6%97%B6%E5%99%A8%EF%BC%9A"><span class="toc-number">30.5.</span> <span class="toc-text">5)创建定时器：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#28-%E5%85%B1%E4%BA%AB%E5%86%85%E5%AD%98"><span class="toc-number">31.</span> <span class="toc-text">28.共享内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#29-%E8%AF%B4%E8%AF%B4%E8%BD%AF%E9%93%BE%E6%8E%A5%E5%92%8C%E7%A1%AC%E9%93%BE%E6%8E%A5%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">32.</span> <span class="toc-text">29.   说说软链接和硬链接的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#30-%E8%AF%B4%E8%AF%B4%E9%9D%99%E6%80%81%E5%BA%93%E5%92%8C%E5%8A%A8%E6%80%81%E5%BA%93%E6%80%8E%E4%B9%88%E5%88%B6%E4%BD%9C%E5%8F%8A%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%EF%BC%8C%E5%8C%BA%E5%88%AB%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-number">33.</span> <span class="toc-text">30.说说静态库和动态库怎么制作及如何使用，区别是什么</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C%EF%BC%9A"><span class="toc-number">33.1.</span> <span class="toc-text">静态库的制作：</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8A%A8%E6%80%81%E5%BA%93%E7%9A%84%E5%88%B6%E4%BD%9C"><span class="toc-number">33.2.</span> <span class="toc-text">动态库的制作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BA%E5%88%AB-%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E5%8A%A0%E8%BD%BD%EF%BC%8C%E5%8A%A0%E8%BD%BD%E9%80%9F%E5%BA%A6%E5%A6%82%E4%BD%95%EF%BC%8C%E5%86%85%E5%AD%98%E5%8D%A0%E7%94%A8%E5%A4%A7%E5%B0%8F%EF%BC%8C%E6%89%A7%E8%A1%8C%E6%95%88%E7%8E%87"><span class="toc-number">33.3.</span> <span class="toc-text">区别;什么时候加载，加载速度如何，内存占用大小，执行效率</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E7%AE%80%E8%BF%B0GDB%E5%B8%B8%E8%A7%81%E7%9A%84%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4%EF%BC%8C%E4%BB%80%E4%B9%88%E6%98%AF%E6%9D%A1%E4%BB%B6%E6%96%AD%E7%82%B9%EF%BC%8C%E5%A4%9A%E8%BF%9B%E7%A8%8B%E4%B8%8B%E5%A6%82%E4%BD%95%E8%B0%83%E8%AF%95"><span class="toc-number">34.</span> <span class="toc-text">31.简述GDB常见的调试命令，什么是条件断点，多进程下如何调试</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E7%AE%80%E8%BF%B0Linux%E7%B3%BB%E7%BB%9F%E6%80%81%E4%B8%8E%E7%94%A8%E6%88%B7%E6%80%81%EF%BC%8C%E4%BB%80%E4%B9%88%E6%97%B6%E5%80%99%E4%BC%9A%E8%BF%9B%E5%85%A5%E7%B3%BB%E7%BB%9F%E6%80%81%EF%BC%9F"><span class="toc-number">35.</span> <span class="toc-text">32.简述Linux系统态与用户态，什么时候会进入系统态？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E4%BB%80%E4%B9%88%E6%98%AF%E9%A1%B5%E8%A1%A8%EF%BC%8C%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E6%9C%89%EF%BC%9F"><span class="toc-number">36.</span> <span class="toc-text">33.    什么是页表，为什么要有？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E7%AE%80%E8%BF%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%ADmalloc%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-number">37.</span> <span class="toc-text">34.   简述操作系统中malloc的实现原理</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-%E7%AE%80%E8%BF%B0%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E7%BC%BA%E9%A1%B5%E4%B8%AD%E6%96%AD%E3%80%82"><span class="toc-number">38.</span> <span class="toc-text">35.    简述操作系统中的缺页中断。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E7%AE%80%E8%BF%B0mmap%E7%9A%84%E5%8E%9F%E7%90%86%E5%92%8C%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF"><span class="toc-number">39.</span> <span class="toc-text">36.   简述mmap的原理和使用场景</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#37-%E4%B8%BA%E4%BB%80%E4%B9%88%E4%BD%BF%E7%94%A8%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">40.</span> <span class="toc-text">37.为什么使用虚拟内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E7%94%A8%E6%88%B7%E7%A9%BA%E9%97%B4%E5%92%8C%E5%86%85%E6%A0%B8%E7%A9%BA%E9%97%B4%E7%9A%84%E9%80%9A%E4%BF%A1%E6%96%B9%E5%BC%8F"><span class="toc-number">41.</span> <span class="toc-text">38.用户空间和内核空间的通信方式</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#38-%E4%B8%AD%E6%96%AD%E7%9A%84%E5%93%8D%E5%BA%94%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%9F%E5%90%AC%E8%AF%B4%E8%BF%87%E9%A1%B6%E5%8D%8A%E9%83%A8%E5%92%8C%E5%BA%95%E5%8D%8A%E9%83%A8%E5%90%97%EF%BC%9F"><span class="toc-number">42.</span> <span class="toc-text">38.中断的响应执行流程？听说过顶半部和底半部吗？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#39-busybox%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F"><span class="toc-number">43.</span> <span class="toc-text">39.   busybox是什么？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#40-%E4%BB%80%E4%B9%88%E6%98%AF%E6%A0%B9%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F"><span class="toc-number">44.</span> <span class="toc-text">40.   什么是根文件系统</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E8%87%AA%E6%97%8B%E9%94%81%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BF%A1%E5%8F%B7%E9%87%8F%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%9F%E4%BA%8C%E8%80%85%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F"><span class="toc-number">45.</span> <span class="toc-text">41.   自旋锁是什么？信号量是什么？二者有什么区别？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E4%B8%BA%E4%BB%80%E4%B9%88%E5%A0%86%E7%9A%84%E7%A9%BA%E9%97%B4%E4%B8%8D%E6%98%AF%E8%BF%9E%E7%BB%AD%E7%9A%84%EF%BC%9F"><span class="toc-number">46.</span> <span class="toc-text">42.   为什么堆的空间不是连续的？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-Linux%E5%86%85%E6%A0%B8%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%EF%BC%88%E8%BF%9B%E7%A8%8B%E3%80%81%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%81%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%EF%BC%89"><span class="toc-number">47.</span> <span class="toc-text">43.Linux内核的组成部分（进程、内存管理、文件系统、网络接口）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-Linux%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%84%E6%88%90%E9%83%A8%E5%88%86%EF%BC%88%E5%86%85%E6%A0%B8%E3%80%81shell%E3%80%81%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E3%80%81%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%EF%BC%89"><span class="toc-number">48.</span> <span class="toc-text">44.Linux系统的组成部分（内核、shell、文件系统、应用程序）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#45-%E7%BA%BF%E7%A8%8B%E7%9A%84%E5%90%8C%E6%AD%A5%E5%92%8C%E4%BA%92%E6%96%A5%E7%9A%84%E5%8C%BA%E5%88%AB%E5%92%8C%E8%81%94%E7%B3%BB"><span class="toc-number">49.</span> <span class="toc-text">45.线程的同步和互斥的区别和联系</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#46-%E5%B8%B8%E8%A7%81%E5%91%BD%E4%BB%A4"><span class="toc-number">50.</span> <span class="toc-text">46.常见命令</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E8%A7%A3%E5%8E%8B%E3%80%81%E5%8E%8B%E7%BC%A9%E5%91%BD%E4%BB%A4"><span class="toc-number">50.1.</span> <span class="toc-text">1.解压、压缩命令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E6%9F%A5%E7%9C%8B%E5%86%85%E5%AD%98"><span class="toc-number">50.2.</span> <span class="toc-text">2.查看内存</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E6%9F%A5%E7%9C%8Bcpu"><span class="toc-number">50.3.</span> <span class="toc-text">3.查看cpu</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-ps-grep-xxx"><span class="toc-number">50.4.</span> <span class="toc-text">4.ps grep|xxx</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BF%AE%E6%94%B9%E6%96%87%E4%BB%B6%E6%9D%83%E9%99%90"><span class="toc-number">50.5.</span> <span class="toc-text">5.修改文件权限</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E6%9F%A5%E7%9C%8B%E5%86%85%E6%A0%B8"><span class="toc-number">50.6.</span> <span class="toc-text">6.查看内核</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E6%9F%A5%E7%9C%8B%E6%A0%88%E5%A4%A7%E5%B0%8F"><span class="toc-number">50.7.</span> <span class="toc-text">7.查看栈大小</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#47-%E8%BF%9B%E7%A8%8B%E7%BB%88%E6%AD%A2"><span class="toc-number">51.</span> <span class="toc-text">47.进程终止</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E7%89%B9%E6%AE%8A%E8%BF%9B%E7%A8%8B"><span class="toc-number">52.</span> <span class="toc-text">48.特殊进程</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#48-%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%B8%AD%E4%BD%BF%E7%94%A8%E8%BE%83%E5%A4%9A%E7%9A%84%E5%87%BD%E6%95%B0"><span class="toc-number">53.</span> <span class="toc-text">48.   多线程中使用较多的函数</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#50-pthread-cond-signal-%E5%92%8C-pthread-cond-broadcast"><span class="toc-number">54.</span> <span class="toc-text">50.pthread_cond_signal()和 pthread_cond_broadcast()</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E9%A9%B1%E5%8A%A8%E9%87%8C%E9%9D%A2%E4%B8%BA%E4%BB%80%E4%B9%88%E9%9C%80%E8%A6%81%E5%B9%B6%E5%8F%91%E5%92%8C%E4%BA%92%E6%96%A5"><span class="toc-number">55.</span> <span class="toc-text">51.驱动里面为什么需要并发和互斥</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E8%BD%AF%E4%B8%AD%E6%96%AD%E5%92%8C%E7%A1%AC%E4%B8%AD%E6%96%AD%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">56.</span> <span class="toc-text">52.   软中断和硬中断的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-fork%E5%92%8Cvfork%E7%9A%84%E5%8C%BA%E5%88%AB"><span class="toc-number">57.</span> <span class="toc-text">52.   fork和vfork的区别</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-%E4%BB%80%E4%B9%88%E6%98%AF%E8%99%9A%E6%8B%9F%E5%86%85%E5%AD%98"><span class="toc-number">58.</span> <span class="toc-text">53.什么是虚拟内存</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E7%9A%84%E4%B8%89%E4%B8%AA%E6%A6%82%E5%BF%B5"><span class="toc-number">59.</span> <span class="toc-text">54.并发编程的三个概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#55-%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5"><span class="toc-number">60.</span> <span class="toc-text">55.   同步和异步</span></a></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="anzhiyufont anzhiyu-icon-history"></i><span>最近发布</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/09/xxxxxxxxxx%201graph%20TB2%20%20%20%20A%5B%E5%BC%80%E5%A7%8B%5D%20--%20B%5B%E4%BB%A5rb%E6%A8%A1%E5%BC%8F%E6%89%93%E5%BC%80Users/" title="无题">无题</a><time datetime="2024-04-09T13:06:58.727Z" title="发表于 2024-04-09 21:06:58">2024-04-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/09/%E4%BC%9A%E8%AE%AE%E6%95%B4%E7%90%86/" title="无题">无题</a><time datetime="2024-04-09T13:06:58.727Z" title="发表于 2024-04-09 21:06:58">2024-04-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/09/2023-08-12-%E4%BF%A1%E4%BB%BB%E7%AE%A1%E7%90%86%E6%96%87%E7%8C%AE%E7%AC%94%E8%AE%B0/" title="信任管理文献笔记">信任管理文献笔记</a><time datetime="2024-04-09T13:06:58.690Z" title="发表于 2024-04-09 21:06:58">2024-04-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/09/2023-08-9-%E8%A1%8C%E4%BA%91%E6%99%BA%E8%83%BD-%E7%AC%94%E8%AF%95%E9%A2%98%E7%AD%94%E6%A1%88/" title="行云智能-笔试测试答卷">行云智能-笔试测试答卷</a><time datetime="2024-04-09T13:06:58.687Z" title="发表于 2024-04-09 21:06:58">2024-04-09</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2024/04/09/2023-08-9-C++%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/" title="C++正则表达式">C++正则表达式</a><time datetime="2024-04-09T13:06:58.685Z" title="发表于 2024-04-09 21:06:58">2024-04-09</time></div></div></div></div></div></div></div></main><footer id="footer"><div id="footer-wrap"></div><div id="footer-bar"><div class="footer-bar-links"><div class="footer-bar-left"><div id="footer-bar-tips"><div class="copyright">&copy;2020 - 2024 By <a class="footer-bar-link" href="/" title="宁康" target="_blank">宁康</a></div></div><div id="footer-type-tips"></div></div><div class="footer-bar-right"><a class="footer-bar-link" target="_blank" rel="noopener" href="https://github.com/anzhiyu-c/hexo-theme-anzhiyu" title="主题">主题</a></div></div></div></footer></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="sidebar-site-data site-data is-center"><a href="/archives/" title="archive"><div class="headline">文章</div><div class="length-num">33</div></a><a href="/tags/" title="tag"><div class="headline">标签</div><div class="length-num">31</div></a><a href="/categories/" title="category"><div class="headline">分类</div><div class="length-num">11</div></a></div><span class="sidebar-menu-item-title">功能</span><div class="sidebar-menu-item"><a class="darkmode_switchbutton menu-child" href="javascript:void(0);" title="显示模式"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span>显示模式</span></a></div><div class="back-menu-list-groups"><div class="back-menu-list-group"><div class="back-menu-list-title">网页</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://blog.anheyu.com/" title="博客"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="/img/favicon.ico" alt="博客"/><span class="back-menu-item-text">博客</span></a></div></div><div class="back-menu-list-group"><div class="back-menu-list-title">项目</div><div class="back-menu-list"><a class="back-menu-item" target="_blank" rel="noopener" href="https://image.anheyu.com/" title="安知鱼图床"><img class="back-menu-item-icon" src= "data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7" onerror="this.onerror=null,this.src=&quot;/img/404.jpg&quot;" data-lazy-src="https://image.anheyu.com/favicon.ico" alt="安知鱼图床"/><span class="back-menu-item-text">安知鱼图床</span></a></div></div></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 文章</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/archives/"><i class="anzhiyufont anzhiyu-icon-box-archive faa-tada" style="font-size: 0.9em;"></i><span> 隧道</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/categories/"><i class="anzhiyufont anzhiyu-icon-shapes faa-tada" style="font-size: 0.9em;"></i><span> 分类</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags faa-tada" style="font-size: 0.9em;"></i><span> 标签</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 友链</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/link/"><i class="anzhiyufont anzhiyu-icon-link faa-tada" style="font-size: 0.9em;"></i><span> 友人帐</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/fcircle/"><i class="anzhiyufont anzhiyu-icon-artstation faa-tada" style="font-size: 0.9em;"></i><span> 朋友圈</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/comments/"><i class="anzhiyufont anzhiyu-icon-envelope faa-tada" style="font-size: 0.9em;"></i><span> 留言板</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 我的</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/music/"><i class="anzhiyufont anzhiyu-icon-music faa-tada" style="font-size: 0.9em;"></i><span> 音乐馆</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/bangumis/"><i class="anzhiyufont anzhiyu-icon-bilibili faa-tada" style="font-size: 0.9em;"></i><span> 追番页</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/album/"><i class="anzhiyufont anzhiyu-icon-images faa-tada" style="font-size: 0.9em;"></i><span> 相册集</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/air-conditioner/"><i class="anzhiyufont anzhiyu-icon-fan faa-tada" style="font-size: 0.9em;"></i><span> 小空调</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="javascript:void(0);"><span> 关于</span></a><ul class="menus_item_child"><li><a class="site-page child faa-parent animated-hover" href="/about/"><i class="anzhiyufont anzhiyu-icon-paper-plane faa-tada" style="font-size: 0.9em;"></i><span> 关于本人</span></a></li><li><a class="site-page child faa-parent animated-hover" href="/essay/"><i class="anzhiyufont anzhiyu-icon-lightbulb faa-tada" style="font-size: 0.9em;"></i><span> 闲言碎语</span></a></li><li><a class="site-page child faa-parent animated-hover" href="javascript:toRandomPost()"><i class="anzhiyufont anzhiyu-icon-shoe-prints1 faa-tada" style="font-size: 0.9em;"></i><span> 随便逛逛</span></a></li></ul></div></div><span class="sidebar-menu-item-title">标签</span><div class="card-tags"><div class="item-headline"></div><div class="card-tag-cloud"><a href="/tags/C/" style="font-size: 0.88rem;">C++<sup>7</sup></a><a href="/tags/C-C/" style="font-size: 0.88rem;">C/C++<sup>1</sup></a><a href="/tags/Carla/" style="font-size: 0.88rem;">Carla<sup>1</sup></a><a href="/tags/Linux%E5%86%85%E6%A0%B8/" style="font-size: 0.88rem;">Linux内核<sup>1</sup></a><a href="/tags/Linux%E7%BD%91%E7%BB%9C/" style="font-size: 0.88rem;">Linux网络<sup>1</sup></a><a href="/tags/Python/" style="font-size: 0.88rem;">Python<sup>1</sup></a><a href="/tags/Socket/" style="font-size: 0.88rem;">Socket<sup>1</sup></a><a href="/tags/TCP-IP/" style="font-size: 0.88rem;">TCP/IP<sup>1</sup></a><a href="/tags/UDP/" style="font-size: 0.88rem;">UDP<sup>1</sup></a><a href="/tags/Vector/" style="font-size: 0.88rem;">Vector<sup>1</sup></a><a href="/tags/%E4%BF%A1%E4%BB%BB%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">信任管理<sup>1</sup></a><a href="/tags/%E4%BF%A1%E8%AA%89%E8%AF%84%E4%BC%B0/" style="font-size: 0.88rem;">信誉评估<sup>1</sup></a><a href="/tags/%E5%85%A5%E4%BE%B5%E6%A3%80%E6%B5%8B/" style="font-size: 0.88rem;">入侵检测<sup>1</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D/" style="font-size: 0.88rem;">内存分配<sup>1</sup></a><a href="/tags/%E5%86%85%E5%AD%98%E7%AE%A1%E7%90%86/" style="font-size: 0.88rem;">内存管理<sup>1</sup></a><a href="/tags/%E5%A0%86/" style="font-size: 0.88rem;">堆<sup>1</sup></a><a href="/tags/%E5%A4%9A%E7%BA%BF%E7%A8%8B/" style="font-size: 0.88rem;">多线程<sup>4</sup></a><a href="/tags/%E5%AE%B9%E5%99%A8/" style="font-size: 0.88rem;">容器<sup>1</sup></a><a href="/tags/%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">强化学习<sup>1</sup></a><a href="/tags/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/" style="font-size: 0.88rem;">操作系统<sup>4</sup></a><a href="/tags/%E6%94%BB%E5%87%BB%E6%A3%80%E6%B5%8B/" style="font-size: 0.88rem;">攻击检测<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E5%85%B1%E4%BA%AB/" style="font-size: 0.88rem;">数据共享<sup>1</sup></a><a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" style="font-size: 0.88rem;">数据结构<sup>1</sup></a><a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" style="font-size: 0.88rem;">机器学习<sup>1</sup></a><a href="/tags/%E6%A0%88/" style="font-size: 0.88rem;">栈<sup>1</sup></a><a href="/tags/%E7%A7%91%E7%A0%94/" style="font-size: 0.88rem;">科研<sup>1</sup></a><a href="/tags/%E7%AE%97%E6%B3%95/" style="font-size: 0.88rem;">算法<sup>1</sup></a><a href="/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/" style="font-size: 0.88rem;">网络编程<sup>1</sup></a><a href="/tags/%E7%BF%BB%E8%BD%AC%E9%93%BE%E8%A1%A8/" style="font-size: 0.88rem;">翻转链表<sup>1</sup></a><a href="/tags/%E8%BD%A6%E8%81%94%E7%BD%91/" style="font-size: 0.88rem;">车联网<sup>2</sup></a><a href="/tags/%E9%93%BE%E8%A1%A8/" style="font-size: 0.88rem;">链表<sup>1</sup></a></div></div><hr/></div></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="anzhiyufont anzhiyu-icon-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="anzhiyufont anzhiyu-icon-arrows-left-right"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="anzhiyufont anzhiyu-icon-gear"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="anzhiyufont anzhiyu-icon-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></button></div></div><div id="nav-music"><a id="nav-music-hoverTips" onclick="anzhiyu.musicToggle()" accesskey="m">播放音乐</a><div id="console-music-bg"></div><meting-js id="8152976493" server="netease" type="playlist" mutex="true" preload="none" theme="var(--anzhiyu-main)" data-lrctype="0" order="random" volume="0.7"></meting-js></div><div id="rightMenu"><div class="rightMenu-group rightMenu-small"><div class="rightMenu-item" id="menu-backward"><i class="anzhiyufont anzhiyu-icon-arrow-left"></i></div><div class="rightMenu-item" id="menu-forward"><i class="anzhiyufont anzhiyu-icon-arrow-right"></i></div><div class="rightMenu-item" id="menu-refresh"><i class="anzhiyufont anzhiyu-icon-arrow-rotate-right" style="font-size: 1rem;"></i></div><div class="rightMenu-item" id="menu-top"><i class="anzhiyufont anzhiyu-icon-arrow-up"></i></div></div><div class="rightMenu-group rightMenu-line rightMenuPlugin"><div class="rightMenu-item" id="menu-copytext"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制选中文本</span></div><div class="rightMenu-item" id="menu-pastetext"><i class="anzhiyufont anzhiyu-icon-paste"></i><span>粘贴文本</span></div><a class="rightMenu-item" id="menu-commenttext"><i class="anzhiyufont anzhiyu-icon-comment-medical"></i><span>引用到评论</span></a><div class="rightMenu-item" id="menu-newwindow"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开</span></div><div class="rightMenu-item" id="menu-copylink"><i class="anzhiyufont anzhiyu-icon-link"></i><span>复制链接地址</span></div><div class="rightMenu-item" id="menu-copyimg"><i class="anzhiyufont anzhiyu-icon-images"></i><span>复制此图片</span></div><div class="rightMenu-item" id="menu-downloadimg"><i class="anzhiyufont anzhiyu-icon-download"></i><span>下载此图片</span></div><div class="rightMenu-item" id="menu-newwindowimg"><i class="anzhiyufont anzhiyu-icon-window-restore"></i><span>新窗口打开图片</span></div><div class="rightMenu-item" id="menu-search"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>站内搜索</span></div><div class="rightMenu-item" id="menu-searchBaidu"><i class="anzhiyufont anzhiyu-icon-magnifying-glass"></i><span>百度搜索</span></div><div class="rightMenu-item" id="menu-music-toggle"><i class="anzhiyufont anzhiyu-icon-play"></i><span>播放音乐</span></div><div class="rightMenu-item" id="menu-music-back"><i class="anzhiyufont anzhiyu-icon-backward"></i><span>切换到上一首</span></div><div class="rightMenu-item" id="menu-music-forward"><i class="anzhiyufont anzhiyu-icon-forward"></i><span>切换到下一首</span></div><div class="rightMenu-item" id="menu-music-playlist" onclick="window.open(&quot;https://y.qq.com/n/ryqq/playlist/8802438608&quot;, &quot;_blank&quot;);" style="display: none;"><i class="anzhiyufont anzhiyu-icon-radio"></i><span>查看所有歌曲</span></div><div class="rightMenu-item" id="menu-music-copyMusicName"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制歌名</span></div></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item menu-link" id="menu-randomPost"><i class="anzhiyufont anzhiyu-icon-shuffle"></i><span>随便逛逛</span></a><a class="rightMenu-item menu-link" href="/categories/"><i class="anzhiyufont anzhiyu-icon-cube"></i><span>博客分类</span></a><a class="rightMenu-item menu-link" href="/tags/"><i class="anzhiyufont anzhiyu-icon-tags"></i><span>文章标签</span></a></div><div class="rightMenu-group rightMenu-line rightMenuOther"><a class="rightMenu-item" id="menu-copy" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-copy"></i><span>复制地址</span></a><a class="rightMenu-item" id="menu-commentBarrage" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-message"></i><span class="menu-commentBarrage-text">关闭热评</span></a><a class="rightMenu-item" id="menu-darkmode" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-circle-half-stroke"></i><span class="menu-darkmode-text">深色模式</span></a><a class="rightMenu-item" id="menu-translate" href="javascript:void(0);"><i class="anzhiyufont anzhiyu-icon-language"></i><span>轉為繁體</span></a></div></div><div id="rightmenu-mask"></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.cbd.int/@fancyapps/ui@5.0.28/dist/fancybox/fancybox.umd.js"></script><script src="https://cdn.cbd.int/instant.page@5.2.0/instantpage.js" type="module"></script><script src="https://cdn.cbd.int/vanilla-lazyload@17.8.5/dist/lazyload.iife.min.js"></script><script src="https://cdn.cbd.int/node-snackbar@0.1.16/dist/snackbar.min.js"></script><canvas id="universe"></canvas><script async src="https://npm.elemecdn.com/anzhiyu-theme-static@1.0.0/dark/dark.js"></script><script>// 消除控制台打印
var HoldLog = console.log;
console.log = function () {};
let now1 = new Date();
queueMicrotask(() => {
  const Log = function () {
    HoldLog.apply(console, arguments);
  }; //在恢复前输出日志
  const grt = new Date("04/01/2021 00:00:00"); //此处修改你的建站时间或者网站上线时间
  now1.setTime(now1.getTime() + 250);
  const days = (now1 - grt) / 1000 / 60 / 60 / 24;
  const dnum = Math.floor(days);
  const ascll = [
    `欢迎使用安知鱼!`,
    `生活明朗, 万物可爱`,
    `
        
       █████╗ ███╗   ██╗███████╗██╗  ██╗██╗██╗   ██╗██╗   ██╗
      ██╔══██╗████╗  ██║╚══███╔╝██║  ██║██║╚██╗ ██╔╝██║   ██║
      ███████║██╔██╗ ██║  ███╔╝ ███████║██║ ╚████╔╝ ██║   ██║
      ██╔══██║██║╚██╗██║ ███╔╝  ██╔══██║██║  ╚██╔╝  ██║   ██║
      ██║  ██║██║ ╚████║███████╗██║  ██║██║   ██║   ╚██████╔╝
      ╚═╝  ╚═╝╚═╝  ╚═══╝╚══════╝╚═╝  ╚═╝╚═╝   ╚═╝    ╚═════╝
        
        `,
    "已上线",
    dnum,
    "天",
    "©2020 By 安知鱼 V1.6.12",
  ];
  const ascll2 = [`NCC2-036`, `调用前置摄像头拍照成功，识别为【小笨蛋】.`, `Photo captured: `, `🤪`];

  setTimeout(
    Log.bind(
      console,
      `\n%c${ascll[0]} %c ${ascll[1]} %c ${ascll[2]} %c${ascll[3]}%c ${ascll[4]}%c ${ascll[5]}\n\n%c ${ascll[6]}\n`,
      "color:#425AEF",
      "",
      "color:#425AEF",
      "color:#425AEF",
      "",
      "color:#425AEF",
      ""
    )
  );
  setTimeout(
    Log.bind(
      console,
      `%c ${ascll2[0]} %c ${ascll2[1]} %c \n${ascll2[2]} %c\n${ascll2[3]}\n`,
      "color:white; background-color:#4fd953",
      "",
      "",
      'background:url("https://npm.elemecdn.com/anzhiyu-blog@1.1.6/img/post/common/tinggge.gif") no-repeat;font-size:450%'
    )
  );

  setTimeout(Log.bind(console, "%c WELCOME %c 你好，小笨蛋.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(
      console,
      "%c ⚡ Powered by 安知鱼 %c 你正在访问 宁康 的博客.",
      "color:white; background-color:#f0ad4e",
      ""
    )
  );

  setTimeout(Log.bind(console, "%c W23-12 %c 你已打开控制台.", "color:white; background-color:#4f90d9", ""));

  setTimeout(
    console.warn.bind(console, "%c S013-782 %c 你现在正处于监控中.", "color:white; background-color:#d9534f", "")
  );
});</script><script async src="/anzhiyu/random.js"></script><div class="js-pjax"><input type="hidden" name="page-type" id="page-type" value="post"></div><script>var visitorMail = "";
</script><script async data-pjax src="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/waterfall/waterfall.js"></script><script src="https://lf3-cdn-tos.bytecdntp.com/cdn/expire-1-M/qrcodejs/1.0.0/qrcode.min.js"></script><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.1.9/icon/ali_iconfont_css.css"><link rel="stylesheet" href="https://cdn.cbd.int/anzhiyu-theme-static@1.0.0/aplayer/APlayer.min.css" media="print" onload="this.media='all'"><script src="https://cdn.cbd.int/anzhiyu-blog-static@1.0.1/js/APlayer.min.js"></script><script src="https://cdn.cbd.int/hexo-anzhiyu-music@1.0.1/assets/js/Meting2.min.js"></script><script src="https://cdn.cbd.int/pjax@0.2.8/pjax.min.js"></script><script>let pjaxSelectors = ["head > title","#config-diff","#body-wrap","#rightside-config-hide","#rightside-config-show",".js-pjax"]
var pjax = new Pjax({
  elements: 'a:not([target="_blank"])',
  selectors: pjaxSelectors,
  cacheBust: false,
  analytics: false,
  scrollRestoration: false
})

document.addEventListener('pjax:send', function () {
  // removeEventListener scroll 
  anzhiyu.removeGlobalFnEvent('pjax')
  anzhiyu.removeGlobalFnEvent('themeChange')

  document.getElementById('rightside').classList.remove('rightside-show')
  
  if (window.aplayers) {
    for (let i = 0; i < window.aplayers.length; i++) {
      if (!window.aplayers[i].options.fixed) {
        window.aplayers[i].destroy()
      }
    }
  }

  typeof typed === 'object' && typed.destroy()

  //reset readmode
  const $bodyClassList = document.body.classList
  $bodyClassList.contains('read-mode') && $bodyClassList.remove('read-mode')
})

document.addEventListener('pjax:complete', function () {
  window.refreshFn()

  document.querySelectorAll('script[data-pjax]').forEach(item => {
    const newScript = document.createElement('script')
    const content = item.text || item.textContent || item.innerHTML || ""
    Array.from(item.attributes).forEach(attr => newScript.setAttribute(attr.name, attr.value))
    newScript.appendChild(document.createTextNode(content))
    item.parentNode.replaceChild(newScript, item)
  })

  GLOBAL_CONFIG.islazyload && window.lazyLoadInstance.update()

  typeof panguInit === 'function' && panguInit()

  // google analytics
  typeof gtag === 'function' && gtag('config', '', {'page_path': window.location.pathname});

  // baidu analytics
  typeof _hmt === 'object' && _hmt.push(['_trackPageview',window.location.pathname]);

  typeof loadMeting === 'function' && document.getElementsByClassName('aplayer').length && loadMeting()

  // prismjs
  typeof Prism === 'object' && Prism.highlightAll()
})

document.addEventListener('pjax:error', e => {
  if (e.request.status === 404) {
    pjax.loadUrl('/404.html')
  }
})</script><script charset="UTF-8" src="https://cdn.cbd.int/anzhiyu-theme-static@1.1.5/accesskey/accesskey.js"></script></div><div id="popup-window"><div class="popup-window-title">通知</div><div class="popup-window-divider"></div><div class="popup-window-content"><div class="popup-tip">你好呀</div><div class="popup-link"><i class="anzhiyufont anzhiyu-icon-arrow-circle-right"></i></div></div></div></body></html>